<!DOCTYPE html>
<html lang="lv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Pokers ar Gemini</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0a;
            background-image: 
                radial-gradient(circle at 20% 50%, #1a1a2e 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, #16213e 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, #0f3460 0%, transparent 50%);
            color: #e2e8f0;
            user-select: none;
            overflow-x: hidden;
            padding: 1rem;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,0.3) 100%),
                radial-gradient(ellipse at top, transparent 0%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .domino-back {
            background-color: #1a1a1a;
            background-image: 
                linear-gradient(135deg, rgba(45,55,72,0.5) 25%, transparent 25%), 
                linear-gradient(225deg, rgba(45,55,72,0.5) 25%, transparent 25%),
                linear-gradient(45deg, rgba(45,55,72,0.5) 25%, transparent 25%),
                linear-gradient(315deg, rgba(45,55,72,0.5) 25%, rgba(26,26,26,0.5) 25%);
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 8px 8px;
            background-repeat: repeat;
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
        }

        .domino-back::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                transparent 40%, 
                rgba(99,179,237,0.05) 50%, 
                transparent 60%
            );
            pointer-events: none;
        }

        /* Stili domino ar aizmugures klasi */
        .domino.domino-back {
            background-color: #1a1a1a !important;
            background-image: 
                linear-gradient(135deg, rgba(45,55,72,0.5) 25%, transparent 25%), 
                linear-gradient(225deg, rgba(45,55,72,0.5) 25%, transparent 25%),
                linear-gradient(45deg, rgba(45,55,72,0.5) 25%, transparent 25%),
                linear-gradient(315deg, rgba(45,55,72,0.5) 25%, #1a1a1a 25%) !important;
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 8px 8px;
            background-repeat: repeat;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .domino {
            width: 48px; 
            height: 96px; 
            background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 6px;
            display: flex; 
            flex-direction: column; 
            justify-content: space-around;
            align-items: center; 
            padding: 4px; 
            margin: 4px;
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.1),
                0 8px 16px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .domino::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(255,255,255,0.2) 50%,
                transparent 70%
            );
            transform: rotate(45deg);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
        }
        
        .domino:hover:not(.disabled) {
            transform: translateY(-6px);
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.2),
                0 16px 32px rgba(0,0,0,0.15);
        }

        .domino:hover:not(.disabled)::before {
            opacity: 1;
            right: 150%;
        }
        
        .domino.trump {
            background: linear-gradient(145deg, #ffd700 0%, #ffed4e 100%);
            box-shadow: 
                0 2px 4px rgba(255,215,0,0.2),
                0 8px 16px rgba(255,215,0,0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .domino.trump::after {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(45deg, #ffd700, #fff59d, #ffd700);
            border-radius: 6px;
            opacity: 0.3;
            z-index: -1;
            filter: blur(4px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .domino.disabled { 
            cursor: not-allowed; 
            opacity: 0.4; 
            background: #6b7280;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .domino-side { width: 80px; height: 40px; flex-direction: row; }
        .domino-side .domino-half { width: 50%; height: 100%; }
        .domino-side .domino-divider { width: 1px; height: 80%; }
        
        .domino-half {
            width: 100%; 
            height: 50%; 
            display: grid;
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            padding: 3px; 
            gap: 1px;
        }
        
        .domino-divider { 
            width: 80%; 
            height: 1px; 
            background: linear-gradient(90deg, transparent, #d1d5db, transparent);
            align-self: center; 
        }
        
        .dot { 
            width: 100%; 
            height: 100%; 
            border-radius: 50%; 
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
            transform: scale(0.65);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        .player-area {
            min-height: 140px; 
            border-radius: 12px; 
            padding: 10px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            position: relative;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.02);
            backdrop-filter: blur(10px);
        }
        
        .active-player {
            background: rgba(99, 179, 237, 0.1);
            border-color: rgba(99, 179, 237, 0.3);
            box-shadow: 
                inset 0 0 20px rgba(99, 179, 237, 0.1),
                0 0 40px rgba(99, 179, 237, 0.1);
        }

        .active-player::before {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(45deg, transparent, rgba(99, 179, 237, 0.3), transparent);
            border-radius: 12px;
            opacity: 0;
            animation: active-sweep 3s linear infinite;
        }

        @keyframes place-subtle {
            0% { 
                transform: translateY(-20px) scale(0.95);
                opacity: 0;
            }
            100% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .turn-starter-indicator {
            border-color: rgba(246, 224, 94, 0.4);
            background: rgba(246, 224, 94, 0.05);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .table-area {
            min-height: 140px; 
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            align-items: center; 
            gap: 8px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }

        .table-area::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.5) 100%),
                conic-gradient(
                    from 0deg at 50% 50%,
                    rgba(99, 179, 237, 0.03) 0deg,
                    transparent 60deg,
                    transparent 180deg,
                    rgba(159, 122, 234, 0.03) 240deg,
                    transparent 360deg
                );
            animation: table-rotate 30s linear infinite;
            pointer-events: none;
        }

        @keyframes table-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .trick-domino-container {
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .trick-domino-container .domino {
            animation: place-subtle 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes place-subtle {
            0% { 
                transform: translateY(-30px) scale(0.9);
                opacity: 0;
            }
            60% {
                transform: translateY(3px) scale(1.02);
                opacity: 1;
            }
            100% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .trick-domino-owner {
            font-size: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: rgba(255,255,255,0.7);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            margin-top: 4px;
            font-weight: 500;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
        }
        
        .winning-domino .domino {
            transform: scale(1.05) !important;
            box-shadow: 
                0 0 0 2px rgba(246, 224, 94, 0.5),
                0 4px 20px rgba(246, 224, 94, 0.3);
            z-index: 10;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1) !important;
        }

        .modal {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); 
            display: flex;
            justify-content: center; 
            align-items: center; 
            z-index: 100;
            backdrop-filter: blur(8px);
            animation: modal-fade-in 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modal-fade-in {
            from { 
                opacity: 0;
                backdrop-filter: blur(0px);
            }
            to { 
                opacity: 1;
                backdrop-filter: blur(8px);
            }
        }
        
        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 16px;
            text-align: center; 
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 90%; 
            width: 600px; 
            position: relative;
            backdrop-filter: blur(20px);
            animation: modal-slide-in 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modal-slide-in {
            from { 
                transform: translateY(-30px) scale(0.95); 
                opacity: 0; 
            }
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
            }
        }
        
        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 16px;
            text-align: center; 
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 90%; 
            width: 600px; 
            position: relative;
            backdrop-filter: blur(20px);
        }
        
        .btn {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white; 
            padding: 12px 24px;
            border-radius: 8px; 
            border: none; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            font-size: 14px;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover:not(:disabled) { 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        .btn:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }
        
        .btn:disabled { 
            background: #4a5568; 
            cursor: not-allowed; 
            opacity: 0.5;
        }
        
        .btn-sm { 
            padding: 6px 12px; 
            font-size: 13px; 
        }
        
        .autoplay-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.4);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .speed-btn {
            background: rgba(74, 85, 104, 0.5);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .speed-btn.active {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            border-color: #4299e1;
            color: white;
        }
        
        .btn-toggle-on { 
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
        }

        .winner-cup {
            position: absolute; 
            top: 10px; 
            right: 10px; 
            font-size: 48px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            animation: winner-appear 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes winner-appear {
            0% { 
                transform: scale(0) rotate(-90deg);
                opacity: 0;
            }
            70% {
                transform: scale(1.1) rotate(10deg);
                opacity: 1;
            }
            100% { 
                transform: scale(1) rotate(0);
                opacity: 1;
            }
        }
        
        .cpu-comment {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #1a1a1a;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .emotion-emoji {
            font-size: 1.1em;
            margin-left: 4px;
            display: inline-block;
            animation: emotionPop 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes emotionPop {
            0% { 
                transform: scale(0);
                opacity: 0;
            }
            70% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% { 
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .lang-switcher {
            position: absolute; 
            top: 1rem; 
            right: 1rem; 
            display: flex;
            gap: 0.5rem; 
            background: rgba(0,0,0,0.4);
            padding: 0.5rem; 
            border-radius: 8px; 
            z-index: 50;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            animation: controls-fade-in 0.8s cubic-bezier(0.4, 0, 0.2, 1) 0.1s backwards;
        }
        
        .lang-btn {
            padding: 0.3rem 0.6rem; 
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px; 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 13px;
            font-weight: 500;
        }
        
        .lang-btn.active {
            background: rgba(66, 153, 225, 0.2);
            border-color: #4299e1;
            color: #63b3ed;
        }
        
        #round-results-body .result-row { 
            padding: 12px; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #round-results-body .result-row:hover {
            background-color: rgba(255,255,255,0.02);
        }
        
        #round-results-body .result-row:last-child { 
            border-bottom: none; 
        }
        
        #round-results-body .player-name { 
            font-weight: 600; 
            font-size: 1.1rem; 
            color: #e2e8f0;
        }
        
        #round-results-body .bid-info { 
            font-size: 0.9rem; 
            color: rgba(255,255,255,0.5);
        }
        
        #round-results-body .points-calculation { 
            font-size: 1.2rem; 
            font-weight: 600;
            color: #f6e05e;
        }

        .gemini-btn { 
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
        }
        
        .gemini-btn:hover:not(:disabled) { 
            box-shadow: 0 4px 12px rgba(159, 122, 234, 0.4);
        }
        
        .loader {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            position: relative;
            background: conic-gradient(from 0deg, transparent 0%, #9f7aea 100%);
            animation: rotate 1.5s linear infinite;
        }

        .loader::before {
            content: '';
            position: absolute;
            inset: 4px;
            border-radius: 50%;
            background: #1a1a1a;
        }
        
        @keyframes rotate { 
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); } 
        }

        .top-left-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 50;
            animation: controls-fade-in 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes controls-fade-in {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .icon-btn {
            width: 40px; 
            height: 40px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-size: 1.2rem;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        .icon-btn:hover { 
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.9);
            border-color: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        #rules-modal-content, #stats-modal-content {
            text-align: left;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 15px;
        }
        
        #rules-modal-content::-webkit-scrollbar,
        #stats-modal-content::-webkit-scrollbar {
            width: 8px;
        }

        #rules-modal-content::-webkit-scrollbar-track,
        #stats-modal-content::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        #rules-modal-content::-webkit-scrollbar-thumb,
        #stats-modal-content::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        #rules-modal-content::-webkit-scrollbar-thumb:hover,
        #stats-modal-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #rules-modal-content h3, #stats-modal-content h3 { 
            font-size: 1.25rem; 
            font-weight: 600; 
            margin-top: 1.5rem; 
            margin-bottom: 0.75rem; 
            color: #e2e8f0;
            position: relative;
            padding-bottom: 0.5rem;
        }

        #rules-modal-content h3::after,
        #stats-modal-content h3::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, #4299e1, transparent);
        }
        
        #rules-modal-content h4 { 
            font-size: 1.1rem; 
            font-weight: 500; 
            margin-top: 1rem; 
            margin-bottom: 0.5rem;
            color: rgba(255,255,255,0.8);
        }
        
        #rules-modal-content p, 
        #rules-modal-content li, 
        #stats-modal-content p { 
            margin-bottom: 0.5rem; 
            color: rgba(255,255,255,0.6);
            line-height: 1.6;
        }
        
        #rules-modal-content ul { 
            list-style-type: none; 
            padding-left: 0;
        }

        #rules-modal-content ul li::before {
            content: 'â–¸';
            color: #4299e1;
            margin-right: 8px;
        }
        
        #stats-modal-content .stat-value { 
            font-weight: 600; 
            color: #f6e05e;
            font-size: 1.1em;
        }

        /* NoÅ†em nevajadzÄ«go zaÄ¼o malu */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* SpÄ“les nosaukuma stili (ja HTML ir elements ar klasi .game-title) */
        .game-title {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 2rem;
            letter-spacing: -0.02em;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: relative;
        }

        .game-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #4299e1, transparent);
        }
    </style>
</head>
<body>
    <div class="top-left-controls">
        <button id="help-btn" class="icon-btn" title="Noteikumi">?</button>
        <button id="stats-btn" class="icon-btn" title="Statistika">ğŸ“Š</button>
    </div>

    <div class="lang-switcher">
        <button id="lang-lv" class="lang-btn active">LV</button>
        <button id="lang-en" class="lang-btn">EN</button>
    </div>

    <div id="game-container" class="max-w-screen-xl mx-auto grid grid-cols-1 lg:grid-cols-5 gap-4">
        <div class="lg:col-span-4">
            <div id="player-area-1" class="player-area mb-4">
                <h2 id="player-name-1" class="text-xl font-bold text-center"></h2>
                <div id="player-hand-1" class="flex justify-center flex-wrap"></div>
                <div class="text-center mt-2 text-sm sm:text-base">
                    <span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-1">?</span> |
                    <span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-1">0</span>
                </div>
            </div>

            <div class="flex justify-between items-center space-x-2 sm:space-x-4">
                <div id="player-area-0" class="player-area w-1/4 sm:w-1/5">
                    <h2 id="player-name-0" class="text-xl font-bold text-center"></h2>
                    <div id="player-hand-0" class="flex flex-wrap justify-center"></div>
                     <div class="text-center mt-2 text-sm sm:text-base">
                        <p><span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-0">?</span></p>
                        <p><span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-0">0</span></p>
                    </div>
                </div>

                <div class="w-1/2 sm:w-3/5">
                    <div id="game-info" class="text-center mb-2">
                        <h1 class="text-2xl sm:text-3xl font-bold">Domino Pokers</h1>
                        <p id="status-message" class="text-lg h-8"></p>
                        <p class="text-xs sm:text-sm"><span data-lang-key="round">Partija</span>: <span id="round-number">1</span>/<span id="total-rounds">5</span></p>
                    </div>
                    <div id="table-area" class="table-area">
                        <div id="bidding-controls" class="hidden"></div>
                    </div>
                     <div id="suit-info" class="text-center mt-2 h-6 font-bold"></div>
                </div>

                 <div id="player-area-2" class="player-area w-1/4 sm:w-1/5">
                    <h2 id="player-name-2" class="text-xl font-bold text-center"></h2>
                    <div id="player-hand-2" class="flex flex-wrap justify-center"></div>
                     <div class="text-center mt-2 text-sm sm:text-base">
                        <p><span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-2">?</span></p>
                        <p><span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-2">0</span></p>
                    </div>
                </div>
            </div>

            <div id="player-area-3" class="player-area mt-4">
                <div class="absolute top-2 right-2 flex items-center gap-2">
                    <div class="autoplay-controls">
                        <button id="autoplay-btn" class="btn btn-sm"></button>
                    </div>
                    <div class="autoplay-controls">
                        <span class="text-xs font-bold" data-lang-key="speed">Ä€trums:</span>
                        <button id="speed-1x" class="btn btn-sm speed-btn active">1x</button>
                        <button id="speed-2x" class="btn btn-sm speed-btn">2x</button>
                        <button id="speed-3x" class="btn btn-sm speed-btn">3x</button>
                    </div>
                </div>
                <h2 id="player-name-3" class="text-xl font-bold text-center" data-lang-key="you">JÅ«s</h2>
                <div id="player-controls" class="text-center my-2">
                     <button id="gemini-advice-btn" class="btn btn-sm gemini-btn hidden">âœ¨ <span data-lang-key="getAdvice">GÄjiena ieteikums</span></button>
                </div>
                <div id="player-hand-3" class="flex justify-center flex-wrap"></div>
                 <div class="text-center mt-2 text-sm sm:text-base">
                    <span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-3">?</span> |
                    <span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-3">0</span>
                </div>
            </div>
        </div>
        
        <div class="lg:col-span-1">
            <div class="sticky top-4">
                <div id="scoreboard" class="scoreboard">
                    <h2 class="text-2xl font-bold mb-4 text-center" data-lang-key="scoreboard">RezultÄti</h2>
                    <div id="scoreboard-body" class="space-y-1"></div>
                </div>
                <div id="history-panel" class="mt-4">
                    <h3 class="text-xl font-bold mb-2 text-center" data-lang-key="trickHistory">GÄjienu VÄ“sture</h3>
                    <div id="history-body" class="space-y-2 bg-slate-800/60 p-2 rounded min-h-[100px] items-center"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="rounds-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl mb-4" data-lang-key="howManyRounds">Cik partijas spÄ“lÄ“siet?</h2>
            <input type="number" id="rounds-input" class="bg-gray-700 text-white p-2 rounded w-full mb-4" value="5" min="1" max="20">
            <div class="mb-4">
                <label for="difficulty-select" class="block mb-2 text-sm font-bold" data-lang-key="difficulty">GrÅ«tÄ«bas lÄ«menis:</label>
                <select id="difficulty-select" class="bg-gray-700 text-white p-2 rounded w-full">
                    <option value="easy" data-lang-key="easy">Viegli</option>
                    <option value="normal" selected data-lang-key="normal">NormÄli</option>
                    <option value="hard" data-lang-key="hard">GrÅ«ti</option>
                </select>
            </div>
            <button id="start-game-btn" class="btn" data-lang-key="startGame">SÄkt spÄ“li</button>
        </div>
    </div>
        
    <div id="suit-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl mb-4" data-lang-key="chooseSuitLead">Ar kuru skaitli sÄkt gÄjienu?</h2>
            <div id="suit-choice-buttons" class="flex justify-center space-x-2"></div>
        </div>
    </div>

    <div id="round-over-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4" data-lang-key="roundResults">Punktu AprÄ“Ä·ins</h2>
            <div id="round-results-body" class="mb-6 text-left space-y-2"></div>
            <div class="flex justify-center gap-4">
                <button id="next-round-btn" class="btn" data-lang-key="continue">TurpinÄt</button>
                <button id="gemini-analysis-btn" class="btn gemini-btn">âœ¨ <span data-lang-key="analyzeRound">AnalizÄ“t partiju</span></button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal hidden">
        <div class="modal-content">
            <div id="winner-animation-container"></div>
            <h2 id="game-over-title" class="text-3xl font-bold mb-4" data-lang-key="gameOver">SpÄ“le Beigusies!</h2>
            <p id="game-over-winner" class="text-xl mb-4"></p>
            <div id="final-scores" class="mb-6 text-left"></div>
            <button id="play-again-btn" class="btn" data-lang-key="playAgain">SpÄ“lÄ“t vÄ“lreiz</button>
        </div>
    </div>

    <div id="gemini-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="gemini-modal-title" class="text-2xl font-bold mb-4">Gemini padoms</h2>
            <div id="gemini-modal-content" class="mb-6 text-left space-y-2 min-h-[100px]">
                 <div class="loader-container flex justify-center items-center">
                    <div class="loader"></div>
                 </div>
            </div>
            <button id="gemini-modal-close-btn" class="btn">AizvÄ“rt</button>
        </div>
    </div>
    
    <div id="rules-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="rules-modal-title" class="text-2xl font-bold mb-4">Noteikumi</h2>
            <div id="rules-modal-content" class="mb-6"></div>
            <button id="rules-modal-close-btn" class="btn">AizvÄ“rt</button>
        </div>
    </div>

    <div id="stats-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="stats-modal-title" class="text-2xl font-bold mb-4">JÅ«su Statistika</h2>
            <div id="stats-modal-content" class="mb-6"></div>
            <button id="stats-modal-close-btn" class="btn">AizvÄ“rt</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE & CONSTANTS ---
    const players = [
        { id: 0, name: 'JÄnis', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 1, name: 'PÄ“teris', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 2, name: 'Andris', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 3, name: 'JÅ«s', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: false },
    ];
    let totalRounds = 5, currentRound = 0, dealerIndex = Math.floor(Math.random() * 4);
    let currentPlayerIndex, trickStartIndex, trick = [], lastTrick = [], trickSuit = null, trickNumber = 0;
    let isPlayerAutoplaying = false;
    let autoplaySpeed = 1;
    let gameState = 'setup';
    let roundState = {};
    let resolveNextRound;
    let cpuDifficulty = 'normal';
    let gameStats = { gamesPlayed: 0, wins: 0, totalScore: 0 };

    const allDominoes = [];
    for (let i = 0; i <= 6; i++) {
        for (let j = i; j <= 6; j++) {
            allDominoes.push({ pips1: i, pips2: j, id: [i, j].sort().join('-'), originalId: `${i}-${j}` });
        }
    }
    const trumps = ['0-0', '1-1', '1-6', '1-5', '1-4', '1-3', '1-2', '0-1'];
    const aces = ['6-6', '5-5', '4-4', '3-3', '2-2', '0-6'];
    
    // --- UI ELEMENTS ---
    const statusMessage = document.getElementById('status-message'), tableArea = document.getElementById('table-area'),
          suitInfo = document.getElementById('suit-info'), suitModal = document.getElementById('suit-modal'), 
          gameOverModal = document.getElementById('game-over-modal'), scoreboardBody = document.getElementById('scoreboard-body'), 
          roundOverModal = document.getElementById('round-over-modal'), autoplayBtn = document.getElementById('autoplay-btn'),
          historyBody = document.getElementById('history-body'),
          geminiAdviceBtn = document.getElementById('gemini-advice-btn'),
          geminiAnalysisBtn = document.getElementById('gemini-analysis-btn'),
          geminiModal = document.getElementById('gemini-modal'),
          rulesModal = document.getElementById('rules-modal'),
          statsModal = document.getElementById('stats-modal'),
          helpBtn = document.getElementById('help-btn'),
          statsBtn = document.getElementById('stats-btn');

    // --- SOUND MANAGER ---
    const soundManager = {
        isMuted: false, 
        synth: new Tone.Synth().toDestination(),
        clickSynth: new Tone.PluckSynth().toDestination(),

        play(soundName) {
            if (this.isMuted || !window.Tone) return;
            try {
                switch(soundName) {
                    case 'click': this.clickSynth.triggerAttackRelease("C4", "8n", Tone.now()); break;
                    case 'shuffle':
                        const now = Tone.now();
                        this.clickSynth.triggerAttackRelease("C2", "16n", now);
                        this.clickSynth.triggerAttackRelease("E2", "16n", now + 0.05);
                        this.clickSynth.triggerAttackRelease("G2", "16n", now + 0.1);
                        this.clickSynth.triggerAttackRelease("C2", "16n", now + 0.15);
                        break;
                    case 'winGame':
                        this.synth.triggerAttackRelease("C5", "8n", Tone.now());
                        this.synth.triggerAttackRelease("E5", "8n", Tone.now() + 0.2);
                        this.synth.triggerAttackRelease("G5", "4n", Tone.now() + 0.4);
                        break;
                    case 'loseGame':
                        this.synth.triggerAttackRelease("G2", "8n", Tone.now());
                        this.synth.triggerAttackRelease("E2", "8n", Tone.now() + 0.2);
                        this.synth.triggerAttackRelease("C2", "4n", Tone.now() + 0.4);
                        break;
                }
            } catch (e) {
                console.error("SkaÅ†as atskaÅ†oÅ¡anas kÄ¼Å«da:", e);
            }
        }
    };

    // --- RULES & TRANSLATIONS ---
    const rules = {
        lv: {
            title: "Domino Pokera Noteikumi",
            content: `
                <h3>SpÄ“les MÄ“rÄ·is</h3>
                <p>Domino pokers ir individuÄla domino spÄ“le, kurÄ Äetri spÄ“lÄ“tÄji vÄc punktus, precÄ«zi paÅ†emot iepriekÅ¡ solÄ«tos stiÄ·us. Galvenais mÄ“rÄ·is ir sasniegt pÄ“c iespÄ“jas vairÄk punktu, pÄrdomÄti plÄnojot un taktiski izjaucot pretinieku plÄnus.</p>
                <h3>SpÄ“les Gaita</h3>
                <h4>1. MaisÄ«Å¡ana un VilkÅ¡ana</h4>
                <p>Katrs spÄ“lÄ“tÄjs saÅ†em 7 domino kauliÅ†us no samaisÄ«ta 28 kauliÅ†u komplekta.</p>
                <h4>2. SolÄ«Å¡ana</h4>
                <p>Katrs spÄ“lÄ“tÄjs pÄ“c kÄrtas nosola, cik stiÄ·us viÅ†Å¡ plÄno iegÅ«t (no 0 lÄ«dz 7). SolÄ«Å¡ana notiek vienÄ aplÄ«.</p>
                <h4>3. IzspÄ“le</h4>
                <p>SpÄ“lÄ“tÄjs, kurÅ¡ sÄk, var likt jebkuru kauliÅ†u. PÄrÄ“jiem spÄ“lÄ“tÄjiem ir jÄseko mastam (jÄliek kauliÅ†Å¡ ar tÄdu paÅ¡u ciparu), ja tas ir iespÄ“jams. Ja mastam sekot nevar, drÄ«kst likt trumpi vai atmest jebkuru citu kauliÅ†u.</p>
				<p>Ja tiek veikts gÄjiens ar trumpi, obligÄti visiem jÄliek trumpis (ja tÄds ir). Ja trumpis nav, tad drÄ«kst atmest jebkuru kauliÅ†u.</p>
				<p>Ja tiek veikts gÄjiens ar dÅ«zi, obligÄti jÄliek atbilstoÅ¡s kauliÅ†Å¡. Ja tÄds nav, tad obligÄti jÄsit ar trumpi. Ja arÄ« trumpis nav, tad drÄ«kst atmest ar jebkuru kauliÅ†u.</p>
				<p>Ja tiek veikts gÄjiens ar neitrÄlu kauliÅ†u piemÄ“ram â€œ4-3â€, obligÄti jÄliek pieprasÄ«tais kauliÅ†Å¡. Ja pieprasÄ«tais kauliÅ†Å¡ nav, tad obligÄti jÄsit ar trumpi. Ja nav nedz pieprasÄ«tais, nedz trumpis, tad drÄ«kst atmest ar jebkuru.</p>
                <h4>Trumpju secÄ«ba (no spÄ“cÄ«gÄkÄ):</h4>
                <ul><li>0-0, 1-1, 1-6, 1-5, 1-4, 1-3, 1-2, 1-0</li></ul>
                <h4>DÅ«Å¾u secÄ«ba (no spÄ“cÄ«gÄkÄ):</h4>
                <ul><li>6-6, 5-5, 4-4, 3-3, 2-2, 0-6. (Izejot ar 0-6, spÄ“lÄ“tÄjs var izvÄ“lÄ“ties, vai prasÄ«t '0' vai '6' mastu).</li></ul>
                <h3>Punktu skaitÄ«Å¡ana</h3>
                <ul>
                    <li><b>+15 punkti</b> par katru precÄ«zi paÅ†emtu stiÄ·i (ja solÄ«ji 3 un paÅ†Ä“mi 3, saÅ†em 45 punktus).</li>
                    <li><b>+5 punkti</b> par katru stiÄ·i virs solÄ«tÄ (ja solÄ«ji 2 un paÅ†Ä“mi 4, saÅ†em 4*5=20 punktus).</li>
                    <li><b>-5 punkti</b> par katru nepaÅ†emto stiÄ·i lÄ«dz solÄ«tajam (ja solÄ«ji 4 un paÅ†Ä“mi 2, saÅ†em -10 punktus).</li>
                    <li><b>+30 bonusa punkti</b>, ja precÄ«zi paÅ†emti visi 7 solÄ«tie stiÄ·i (kopÄ 7*15+30=135 punkti).</li>
                    <li><b>-30 punkti</b>, ja solÄ«ti visi 7, bet nav paÅ†emti.</li>
                </ul>`
        },
        en: {
            title: "Domino Poker Rules",
            content: `
                <h3>Game Objective</h3>
                <p>Domino Poker is an individual domino game for four players who aim to score points by accurately taking previously bid tricks. Strategic planning and interference with opponents are essential for winning.</p>
                <h3>Gameplay</h3>
                <h4>1. Shuffling and Drawing</h4>
                <p>Each player draws 7 dominoes from a shuffled 28-tile set.</p>
                <h4>2. Bidding</h4>
                <p>Each player bids in turn how many tricks they plan to take (from 0 to 7). There is only one round of bidding.</p>
                <h4>3. Play</h4>
				<p>If a move is made with a trump, everyone must play a trump (if they have one). If no trump is available, any tile may be discarded.</p>
				<p>If a move is made with an ace, the corresponding tile must be played. If such a tile is unavailable, a trump must be played. If no trump is available, any tile may be discarded.</p>
				<p>If a move is made with a neutral tile, for example â€œ4-3â€, the requested tile must be played. If the requested tile is unavailable, a trump must be played. If neither the requested tile nor a trump is available, any tile may be discarded.</p>
                <p>The lead player can play any tile. Other players must follow suit (play a tile with the same number) if they can. If you cannot follow suit, you may play a trump or discard any other tile.</p>
                <h4>Trump order (highest first):</h4>
                <ul><li>0-0, 1-1, 1-6, 1-5, 1-4, 1-3, 1-2, 1-0</li></ul>
                <h4>Ace order (highest first):</h4>
                <ul><li>6-6, 5-5, 4-4, 3-3, 2-2, 0-6. (When leading with 0-6, the player can choose to call for either the '0' or '6' suit).</li></ul>
                <h3>Scoring</h3>
                <ul>
                    <li><b>+15 points</b> for each trick taken if the bid was met exactly (e.g., bid 3, took 3 = 45 points).</li>
                    <li><b>+5 points</b> for each trick taken if the bid was exceeded (e.g., bid 2, took 4 = 20 points).</li>
                    <li><b>-5 points</b> for each trick missed below the bid (e.g., bid 4, took 2 = -10 points).</li>
                    <li><b>+30 bonus points</b> for bidding and taking all 7 tricks (total 7*15+30=135 points).</li>
                    <li><b>-30 points</b> for bidding 7 tricks but failing to take them all.</li>
                </ul>`
        }
    };
    
    const translations = {
        lv: {
            you: 'JÅ«s', bid: 'SolÄ«ja', taken: 'PaÅ†Ä“ma', round: 'Partija', scoreboard: 'RezultÄti', howManyRounds: 'Cik partijas spÄ“lÄ“siet?',
            startGame: 'SÄkt spÄ“li', chooseSuitLead: 'Ar kuru skaitli sÄkt gÄjienu?', roundResults: 'Punktu AprÄ“Ä·ins', continue: 'TurpinÄt',
            gameOver: 'SpÄ“le Beigusies!', playAgain: 'SpÄ“lÄ“t vÄ“lreiz', mustFollow: 'NederÄ«gs gÄjiens! JÄseko mastam vai jÄliek trumpis.',
            playerTurn: (name) => `${name} gÄjiens...`, bidding: (name) => `${name} solÄ«s...`, bidMade: (name, bid) => `${name} sola ${bid}`,
            gameStarts: (name) => `SpÄ“le sÄkas! ${name} sÄk.`, trickWon: (name) => `${name} paÅ†em stiÄ·i!`, roundOver: 'Partija beigusies! Skaita punktus...',
            shuffling: 'Maisa kauliÅ†us...', bidPrompt: 'Cik stiÄ·us jÅ«s solÄ«siet?',
            winnerIs: (name, score) => `UzvarÄ“tÄjs ir ${name} ar ${score} punktiem!`, finalScoresTitle: 'Gala RezultÄti:', points: 'punkti',
            roundResultText: (bid, taken) => `SolÄ«ja ${bid}, PaÅ†Ä“ma ${taken}`, pointsSuffix: 'punkti', suitLead: (suit) => `JÄseko: ${suit}`,
            trumpSuit: 'Trumpji', enableAutoplay: 'IeslÄ“gt CPU', disableAutoplay: 'IzslÄ“gt CPU',
            trickHistory: 'GÄjienu VÄ“sture', noHistory: 'VÄ“l nav nospÄ“lÄ“ts neviens stiÄ·is.', speed: 'Ä€trums:',
            getAdvice: 'GÄjiena ieteikums', analyzeRound: 'AnalizÄ“t partiju', adviceTitle: 'Gemini padoms', analysisTitle: 'Gemini analÄ«ze',
            difficulty: 'GrÅ«tÄ«bas lÄ«menis', easy: 'Viegli', normal: 'NormÄli', hard: 'GrÅ«ti',
            statsTitle: 'JÅ«su Statistika', gamesPlayed: 'NospÄ“lÄ“tÄs spÄ“les', wins: 'Uzvaras', totalScore: 'KopÄ“jais punktu skaits'
        },
        en: {
            you: 'You', bid: 'Bid', taken: 'Taken', round: 'Round', scoreboard: 'Scoreboard', howManyRounds: 'How many rounds to play?',
            startGame: 'Start Game', chooseSuitLead: 'Which number to lead with?', roundResults: 'Point Calculation', continue: 'Continue',
            gameOver: 'Game Over!', playAgain: 'Play Again', mustFollow: 'Invalid move! You must follow suit or play a trump.',
            playerTurn: (name) => `${name}'s turn...`, bidding: (name) => `${name} is bidding...`, bidMade: (name, bid) => `${name} bids ${bid}`,
            gameStarts: (name) => `The game begins! ${name} starts.`, trickWon: (name) => `${name} takes the trick!`, roundOver: 'Round over! Calculating scores...',
            shuffling: 'Shuffling dominoes...', bidPrompt: 'How many tricks will you bid?',
            winnerIs: (name, score) => `The winner is ${name} with ${score} points!`, finalScoresTitle: 'Final Scores:', points: 'points',
            roundResultText: (bid, taken) => `Bid ${bid}, Took ${taken}`, pointsSuffix: 'points', suitLead: (suit) => `Suit to follow: ${suit}`,
            trumpSuit: 'Trumps', enableAutoplay: 'Enable CPU', disableAutoplay: 'Disable CPU',
            trickHistory: 'Trick History', noHistory: 'No tricks played yet.', speed: 'Speed:',
            getAdvice: 'Get Advice', analyzeRound: 'Analyze Round', adviceTitle: 'Gemini Advice', analysisTitle: 'Gemini Analysis',
            difficulty: 'Difficulty Level', easy: 'Easy', normal: 'Normal', hard: 'Hard',
            statsTitle: 'Your Statistics', gamesPlayed: 'Games Played', wins: 'Wins', totalScore: 'Total Score'
        }
    };
    const cpuComments = {
        lv: {
            bidding: {
                high: ["Å oreiz spÄ“lÄ“Å¡u nopietni!", "Man ir laba roka!", "Es bÅ«Å¡u agresÄ«vs.", "Lai sÄkas cÄ«Å†a!"],
                low: ["JÄbÅ«t uzmanÄ«gam...", "Hmm, ne pÄrÄk daudz.", "Å oreiz piesardzÄ«gi.", "RedzÄ“s, kas sanÄks."],
                zero: ["NullÄ«te bÅ«s.", "Nevienu nepaÅ†emÅ¡u!", "BloÄ·Ä“Å¡u citus.", "TaktiskÄ nulle."]
            },
            playing: {
                leadStrong: ["SÄksim ar spÄ“ku!", "Å is noteikti paÅ†ems!", "Mans labÄkais gÄjiens.", "UzbrÅ«kam!"],
                leadWeak: ["PaskatÄ«simies...", "VarbÅ«t kÄds pÄrspÄ“s.", "SÄkÅ¡u maigi.", "DroÅ¡s gÄjiens."],
                followWin: ["PaÅ†emÅ¡u Å¡o!", "Mans stiÄ·is!", "Neviens nepÄrspÄ“s.", "Perfekti!"],
                followLose: ["Lai kÄds cits Å†em.", "SaglabÄÅ¡u spÄ“ku.", "PagaidÄm zaudÄ“ju.", "Nav vÄ“rts cÄ«nÄ«ties."],
                mustWin: ["Man Å¡is jÄpaÅ†em!", "Kritiski svarÄ«gs!", "NedrÄ«kstu zaudÄ“t!", "JÄvinnÄ“!"],
                frustrated: ["Ak nÄ“!", "Tas nebija plÄnÄ...", "KÄpÄ“c tÄ?", "NepatÄ«kami!"]
            },
            trickEnd: {
                won: ["JÄ! PaÅ†Ä“mu!", "KÄ plÄnoju!", "Labi sanÄca!", "Mans stiÄ·is! ğŸ’ª"],
                lost: ["Nu labi...", "Lai viÅ†am paliek.", "NÄkamreiz.", "Hmm..."],
                critical: ["Perfekti!", "TieÅ¡i ko vajadzÄ“ja!", "Super!", "PlÄns strÄdÄ! ğŸ¯"],
                bad: ["Ak nÄ“!", "Tas nav labi!", "ProblÄ“mas...", "Vai tieÅ¡Äm? ğŸ˜°"]
            }
        },
        en: {
            bidding: {
                high: ["I'll play seriously!", "Good hand here!", "Going aggressive.", "Let's fight!"],
                low: ["Need to be careful...", "Hmm, not too much.", "Playing safe.", "We'll see."],
                zero: ["Going for zero.", "Won't take any!", "Blocking others.", "Tactical nil."]
            },
            playing: {
                leadStrong: ["Starting strong!", "This will win!", "My best move.", "Attack!"],
                leadWeak: ["Let's see...", "Maybe someone beats it.", "Starting soft.", "Safe play."],
                followWin: ["Taking this!", "My trick!", "No one beats this.", "Perfect!"],
                followLose: ["Let others take it.", "Saving strength.", "Losing for now.", "Not worth it."],
                mustWin: ["Must take this!", "Critical trick!", "Can't lose!", "Need to win!"],
                frustrated: ["Oh no!", "Not as planned...", "Why?", "Not good!"]
            },
            trickEnd: {
                won: ["Yes! Got it!", "As planned!", "Nice one!", "My trick! ğŸ’ª"],
                lost: ["Oh well...", "Keep it.", "Next time.", "Hmm..."],
                critical: ["Perfect!", "Exactly what I needed!", "Great!", "Plan works! ğŸ¯"],
                bad: ["Oh no!", "That's bad!", "Problems...", "Really? ğŸ˜°"]
            }
        }
    };
	
    let currentLanguage = 'lv';
    function setLanguage(lang) {
        currentLanguage = lang;
        document.documentElement.lang = lang;
        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.dataset.langKey;
            const translation = translations[lang][key];
            if (translation) {
                const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE && node.nodeValue.trim().length > 0);
                 if (el.tagName === 'OPTION') {
                    el.textContent = translation;
                } else if (textNode) {
                    textNode.textContent = translation;
                } else if (el.querySelector('span')) {
                    el.querySelector('span').textContent = ' ' + translation;
                } else {
                    el.textContent = translation;
                }
            }
        });
        if (!isPlayerAutoplaying) players[3].name = translations[lang].you;
        document.getElementById('lang-lv').classList.toggle('active', lang === 'lv');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en');
        updateAutoplayButton(); 
        updateUI(); 
    }

    function getRandomComment(category, type) {
        const comments = cpuComments[currentLanguage][category][type];
        return comments[Math.floor(Math.random() * comments.length)];
    }

    function showCPUComment(playerIndex, comment, duration = 3000) {
        if (!players[playerIndex].isCPU) return;
        const playerArea = document.getElementById(`player-area-${playerIndex}`);
        let commentEl = playerArea.querySelector('.cpu-comment');
        if (!commentEl) {
            commentEl = document.createElement('div');
            commentEl.className = 'cpu-comment';
            playerArea.insertBefore(commentEl, playerArea.firstChild);
        }
        commentEl.textContent = comment;
        commentEl.style.opacity = '1';
        setTimeout(() => { commentEl.style.opacity = '0'; }, duration);
    }

    function showPlayerEmotion(playerIndex, emotion) {
        const playerName = document.getElementById(`player-name-${playerIndex}`);
        const existingEmoji = playerName.querySelector('.emotion-emoji');
        if (existingEmoji) existingEmoji.remove();

        const emoji = document.createElement('span');
        emoji.className = 'emotion-emoji';
        switch(emotion) {
            case 'happy': emoji.textContent = ' ğŸ˜Š'; break;
            case 'sad': emoji.textContent = ' ğŸ˜”'; break;
            case 'angry': emoji.textContent = ' ğŸ˜¤'; break;
            case 'shocked': emoji.textContent = ' ğŸ˜±'; break;
            case 'cool': emoji.textContent = ' ğŸ˜'; break;
            case 'thinking': emoji.textContent = ' ğŸ¤”'; break;
        }
        playerName.appendChild(emoji);
        setTimeout(() => {
            emoji.style.opacity = '0';
            setTimeout(() => emoji.remove(), 500);
        }, 4000);
    }

    // --- DOMINO & GAME LOGIC ---
    function getDominoType(domino) {
        if (!domino) return 'normal';
        if (trumps.includes(domino.id)) return 'trump';
        if (aces.includes(domino.id)) return 'ace';
        return 'normal';
    }
    
    function getDominoRank(domino, currentTrickSuit) {
        if (!domino) return 0;
        const type = getDominoType(domino);

        if (type === 'trump') {
            return 30 + trumps.length - trumps.indexOf(domino.id);
        }

        if (currentTrickSuit !== null && currentTrickSuit !== 'trump') {
            const hasSuit = domino.pips1 === currentTrickSuit || domino.pips2 === currentTrickSuit;
            if (hasSuit) {
                if (type === 'ace' && domino.pips1 === domino.pips2) {
                    return 20 + domino.pips1;
                }
                const otherPip = domino.pips1 === currentTrickSuit ? domino.pips2 : domino.pips1;
                return 10 + otherPip;
            } else {
                return 0;
            }
        }
        
        if (type === 'ace') {
            return 20 + aces.length - aces.indexOf(domino.id);
        }
        return Math.max(domino.pips1, domino.pips2);
    }

    function createPips(container, count) {
        container.innerHTML = '';
        const pipsLayout = { 1:['5'], 2:['1','9'], 3:['1','5','9'], 4:['1','3','7','9'], 5:['1','3','5','7','9'], 6:['1','3','4','6','7','9'] };
        if (pipsLayout[count]) {
            pipsLayout[count].forEach(pos => {
                const dot = document.createElement('div'); dot.className = 'dot';
                dot.style.gridArea = `${Math.ceil(parseInt(pos)/3)}/${((parseInt(pos)-1)%3)+1}`;
                container.appendChild(dot);
            });
        }
    }

    function createDominoElement(domino, isFaceDown = false, isSidePlayer = false) {
        const dominoEl = document.createElement('div');
        dominoEl.className = 'domino';
        if (isSidePlayer) dominoEl.classList.add('domino-side');
        if (domino) dominoEl.dataset.id = domino.originalId;

        if (isFaceDown) {
            dominoEl.classList.add('domino-back');
            return dominoEl;
        }

        const half1 = document.createElement('div'); half1.className = 'domino-half'; createPips(half1, domino.pips1);
        const divider = document.createElement('div'); divider.className = 'domino-divider';
        const half2 = document.createElement('div'); half2.className = 'domino-half'; createPips(half2, domino.pips2);

        dominoEl.append(half1, divider, half2);
        return dominoEl;
    }
    
    // --- UI UPDATES ---
    function updateUI() {
        players.forEach((player, index) => {
            const handEl = document.getElementById(`player-hand-${index}`),
                  bidEl = document.getElementById(`player-bid-${index}`),
                  tricksEl = document.getElementById(`player-tricks-${index}`),
                  playerAreaEl = document.getElementById(`player-area-${index}`);
            document.getElementById(`player-name-${index}`).textContent = player.name;
            
            playerAreaEl.classList.toggle('active-player', index === currentPlayerIndex && gameState !== 'setup' && gameState !== 'bidding');
            
            const isTurnStarter = index === trickStartIndex && (gameState === 'bidding' || (gameState === 'playing' && trick.length === 0));
            playerAreaEl.classList.toggle('turn-starter-indicator', isTurnStarter);

            const isSide = index === 0 || index === 2;
            handEl.innerHTML = '';
            const showHand = index === 3 || !player.isCPU;
            player.hand.sort((a,b) => getDominoRank(b, null) - getDominoRank(a, null)).forEach(d => {
                const dominoEl = createDominoElement(d, !showHand, isSide);
                handEl.appendChild(dominoEl);
            });
            bidEl.textContent = player.bid === null ? '?' : player.bid;
            tricksEl.textContent = player.tricksWon;
        });

        tableArea.querySelectorAll('.trick-domino-container, #bidding-controls').forEach(el => el.remove());
        
        if (gameState === 'bidding' && currentPlayerIndex === 3 && !isPlayerAutoplaying) {
            getPlayerBid(); 
        }

        trick.forEach((play) => {
            const container = document.createElement('div');
            container.className = 'trick-domino-container';
            
            const dominoEl = createDominoElement(play.domino);
            dominoEl.style.transform = 'scale(0.85)';
            container.appendChild(dominoEl);
            
            const ownerEl = document.createElement('div');
            ownerEl.className = 'trick-domino-owner';
            ownerEl.textContent = players[play.playerIndex].name;
            container.appendChild(ownerEl);
            
            tableArea.appendChild(container);
        });

        document.getElementById('round-number').textContent = currentRound > 0 ? currentRound : 1;
        document.getElementById('total-rounds').textContent = totalRounds;
        suitInfo.textContent = trickSuit !== null && trickSuit !== 'trump' ? `${translations[currentLanguage].suitLead(trickSuit)}` : (trickSuit === 'trump' ? translations[currentLanguage].trumpSuit : '');
        
        geminiAdviceBtn.classList.toggle('hidden', !(gameState === 'playing' && currentPlayerIndex === 3 && !isPlayerAutoplaying));

        updatePlayerHandClickability();
        updateScoreboard();
        updateHistoryUI();
    }
    
    function updateScoreboard() {
        scoreboardBody.innerHTML = '';
        const sortedPlayers = [...players].sort((a,b) => b.score - a.score);
        sortedPlayers.forEach((player, idx) => {
            const playerRow = document.createElement('div');
            playerRow.className = `flex justify-between items-center p-2 rounded ${idx === 0 ? 'bg-yellow-600/30' : 'bg-slate-700/50'}`;
            playerRow.innerHTML = `<span class="font-bold">${idx + 1}. ${player.name}</span><span class="text-lg">${player.score}</span>`;
            scoreboardBody.appendChild(playerRow);
        });
    }

    // HISTORY PANEL REWORK
    function updateHistoryUI() {
        historyBody.innerHTML = '';
        if (!roundState.trickHistory || roundState.trickHistory.length === 0) {
            const noHistoryEl = document.createElement('p');
            noHistoryEl.textContent = translations[currentLanguage].noHistory;
            noHistoryEl.className = 'text-center text-slate-400 p-4';
            historyBody.appendChild(noHistoryEl);
            return;
        }

        // PaÅ†emam tikai pÄ“dÄ“jo gÄjienu no vÄ“stures
        const lastTrickData = roundState.trickHistory[roundState.trickHistory.length - 1];
        const index = roundState.trickHistory.length - 1;

        const trickContainer = document.createElement('div');
        trickContainer.className = 'p-2 border-b border-slate-700 last:border-b-0';

        const trickHeader = document.createElement('h4');
        trickHeader.className = 'font-bold text-xs text-slate-300 mb-1 pl-1';
        trickHeader.textContent = `StiÄ·is ${index + 1}`;
        trickContainer.appendChild(trickHeader);

        const playsContainer = document.createElement('div');
        playsContainer.className = 'flex flex-row justify-center items-start gap-1'; 
        
        const winnerPlay = determineTrickWinner(lastTrickData.plays, lastTrickData.trickSuit);

        lastTrickData.plays.forEach(play => {
            const playContainer = document.createElement('div');
            playContainer.className = 'flex flex-col items-center text-center w-1/4';

            const dominoEl = createDominoElement(play.domino);
            dominoEl.style.transform = 'scale(0.4)';
            dominoEl.style.margin = '-12px 0';
            
            if (winnerPlay && play.playerIndex === winnerPlay.playerIndex) {
                dominoEl.classList.add('history-domino-winner');
            }

            const playerNameEl = document.createElement('span');
            playerNameEl.textContent = players[play.playerIndex].name;
            playerNameEl.className = 'text-slate-400 text-[10px] mt-2 truncate w-full';

            playContainer.appendChild(dominoEl);
            playContainer.appendChild(playerNameEl);
            playsContainer.appendChild(playContainer);
        });

        trickContainer.appendChild(playsContainer);
        historyBody.appendChild(trickContainer);
    }


    function updatePlayerHandClickability() {
        const isPlayerTurn = currentPlayerIndex === 3 && gameState === 'playing' && !isPlayerAutoplaying;
        const handElements = document.querySelectorAll('#player-hand-3 .domino');
        handElements.forEach(el => {
            const domino = players[3].hand.find(d => d.originalId === el.dataset.id);
            const isValid = isMoveValid(domino, players[3]);
            el.classList.toggle('disabled', !isPlayerTurn || !isValid);
        });
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    
    function countRemainingTrumps() { return trumps.filter(t => !roundState.trumpsPlayed.includes(t)).length; }
    function countRemainingAces() { return aces.filter(a => !roundState.acesPlayed.includes(a)).length; }
    function getSuitCount(hand, suit) { return hand.filter(d => d.pips1 === suit || d.pips2 === suit).length; }

    function getPlayerSuitExhaustion(playerIndex, suit) {
        const plays = roundState.trickHistory || [];
        for (let trick of plays) {
            const playerPlay = trick.plays.find(p => p.playerIndex === playerIndex);
            if (playerPlay && trick.trickSuit === suit && playerPlay.domino.pips1 !== suit && playerPlay.domino.pips2 !== suit) {
                return true; 
            }
        }
        return false;
    }

    function analyzeOpponentsBids() {
        const totalBid = players.reduce((sum, p) => sum + (p.bid || 0), 0);
        return { totalBid, averageBid: totalBid / 4, isOverbid: totalBid > 7, isUnderbid: totalBid < 7 };
    }

    function evaluateHandStrength(hand) {
        let strength = 0;
        hand.forEach(d => {
            if (getDominoType(d) === 'trump') strength += (8 - trumps.indexOf(d.id)) * 3;
            else if (getDominoType(d) === 'ace') {
                const support = getSuitCount(hand, d.pips1) - 1;
                let aceValue = (6 - aces.indexOf(d.id)) * 2;
                if (support === 0) aceValue *= 0.3; else if (support === 1) aceValue *= 0.6; else if (support === 2) aceValue *= 0.85;
                strength += aceValue;
            }
        });
        for (let suit = 0; suit <= 6; suit++) {
            const count = getSuitCount(hand, suit);
            if (count >= 4) strength += (count - 3) * 2;
            if (count === 1) strength -= 1;
        }
        return strength;
    }

    function determineObjective(player) {
        const tricksNeeded = player.bid - player.tricksWon;
        const remainingTricks = 7 - trickNumber + 1;
        if (player.bid === 0) return 'AVOID_ALL';
        if (tricksNeeded <= 0) return 'AVOID';
        if (tricksNeeded >= remainingTricks) return 'MUST_WIN';
        if (tricksNeeded > remainingTricks * 0.7) return 'NEED_WIN';
        return 'FLEXIBLE';
    }

    function analyzeTrick() {
        const currentWinner = determineTrickWinner(trick, trickSuit);
        return {
            expectedWinner: currentWinner ? currentWinner.playerIndex : -1,
            highCards: trick.filter(t => getDominoRank(t.domino, trickSuit) > 15).length,
            trumpsPlayed: trick.filter(t => getDominoType(t.domino) === 'trump').length,
            remainingPlayers: 4 - trick.length
        };
    }

    function evaluateTrickValue(player, context) {
        const tricksNeeded = player.bid - player.tricksWon;
        const urgency = tricksNeeded / context.remainingTricks;
        if (urgency >= 1) return 1.0; if (urgency >= 0.8) return 0.8; if (urgency >= 0.6) return 0.6; return 0.4;
    }

    function recordTrickHistory() {
        roundState.trickHistory.push({
            trickNumber: trickNumber,
            trickSuit: trickSuit,
            plays: [...trick]
        });
    }

    // --- GAME FLOW ---
    async function runGame() {
        const cpuNames = {
            lv: { male: ["JÄnis", "PÄ“teris", "Andris", "MÄris", "Juris", "Aigars", "Edgars", "KÄrlis", "ArtÅ«rs", "Rihards"], female: ["Anna", "LÄ«ga", "Ilze", "KristÄ«ne", "Laura", "Inga", "ElÄ«na", "Sanita", "Dace", "Zane"] },
            en: { male: ["John", "Peter", "Andrew", "Mark", "James", "Robert", "Michael", "David", "William", "Richard"], female: ["Mary", "Emma", "Sarah", "Lisa", "Jennifer", "Jessica", "Michelle", "Amanda", "Ashley", "Emily"] }
        };
        const allNames = [...cpuNames[currentLanguage].male, ...cpuNames[currentLanguage].female];
        shuffleArray(allNames);
        players.filter(p => p.isCPU).forEach((p, i) => p.name = allNames[i]);
    
        currentRound = 0;
        players.forEach(p => p.score = 0);
        isPlayerAutoplaying = false; 
        updateAutoplayButton();
    
        while(currentRound < totalRounds) {
            currentRound++;
            roundOverModal.classList.add('hidden');
            await startRound();
        }
        showGameOver();
    }
    
    function startRound() {
        return new Promise(async roundResolve => {
            resolveNextRound = roundResolve; 
            gameState = 'bidding';
            statusMessage.textContent = translations[currentLanguage].shuffling;
            soundManager.play('shuffle');
            trickNumber = 0; trick = []; trickSuit = null;
            roundState = { playedDominoes: [], trumpsPlayed: [], acesPlayed: [], trickHistory: [] };

            tableArea.innerHTML = '';
            suitInfo.textContent = '';
            players.forEach(p => { p.hand = []; p.bid = null; p.tricksWon = 0; });
            
            const shuffledDominoes = [...allDominoes];
            shuffleArray(shuffledDominoes);
            for(let i = 0; i < 28; i++) players[i % 4].hand.push(shuffledDominoes[i]);
            
            dealerIndex = (dealerIndex + 1) % 4;
            currentPlayerIndex = (dealerIndex + 1) % 4;
            trickStartIndex = currentPlayerIndex;
            updateUI();
            
            await sleep(1000);
            await startBidding();
            
            gameState = 'playing';
            while(trickNumber < 7) {
                await playTrick();
            }
            endRound();
        });
    }
    
    async function startBidding() {
        for (let i = 0; i < 4; i++) {
            const player = players[currentPlayerIndex];
            statusMessage.textContent = translations[currentLanguage].bidding(player.name);
            document.querySelectorAll('.player-area').forEach(el => el.classList.remove('active-player'));
            document.getElementById(`player-area-${player.id}`).classList.add('active-player');
            
            const isAutoplaying = player.id === 3 && isPlayerAutoplaying;
            if (player.isCPU || isAutoplaying) {
                player.bid = getCPUBid(player);
				if (player.isCPU) {
                    let commentType = player.bid >= 4 ? 'high' : (player.bid === 0 ? 'zero' : 'low');
                    showCPUComment(player.id, getRandomComment('bidding', commentType));
                }
                await sleep(1200 / autoplaySpeed);
            } else {
                player.bid = await getPlayerBid();
            }
            
            tableArea.querySelector('#bidding-controls')?.remove();
            statusMessage.textContent = translations[currentLanguage].bidMade(player.name, player.bid);
            updateUI();
            await sleep(500 / autoplaySpeed);
            currentPlayerIndex = (currentPlayerIndex + 1) % 4;
        }
        document.querySelectorAll('.player-area').forEach(el => el.classList.remove('active-player'));
        currentPlayerIndex = trickStartIndex;
        statusMessage.textContent = translations[currentLanguage].gameStarts(players[currentPlayerIndex].name);
        updateUI();
        await sleep(1500 / autoplaySpeed);
    }

    function getPlayerBid() {
        return new Promise(resolve => {
            let biddingControls = document.getElementById('bidding-controls');
            if (!biddingControls) {
                biddingControls = document.createElement('div');
                biddingControls.id = 'bidding-controls';
                tableArea.appendChild(biddingControls);
            }
            
            statusMessage.textContent = translations[currentLanguage].bidPrompt;
            biddingControls.innerHTML = '';
            biddingControls.classList.remove('hidden');
            for(let i = 0; i <= 7; i++) {
                const btn = document.createElement('button');
                btn.className = 'btn m-1'; btn.textContent = i;
                btn.onclick = () => {
                    biddingControls.classList.add('hidden');
                    resolve(i);
                };
                biddingControls.appendChild(btn);
            }
        });
    }

    function playTrick() {
        return new Promise(async resolve => {
            trick = []; trickSuit = null;
            trickNumber++;
            trickStartIndex = currentPlayerIndex;
            updateUI();

            for (let i = 0; i < 4; i++) {
                const player = players[currentPlayerIndex];
                statusMessage.textContent = translations[currentLanguage].playerTurn(player.name);
                updateUI();
                
                let playedDomino;
                const isAutoplaying = player.id === 3 && isPlayerAutoplaying;

                if (player.isCPU || isAutoplaying) {
                    await sleep((isPlayerAutoplaying ? 800 : 1500) / autoplaySpeed);
                    const moveChoice = getCPUMove(player);
					if (player.isCPU) {
                        if (trick.length === 0) {
                            const isStrongLead = getDominoType(moveChoice.domino) !== 'normal';
                            showCPUComment(player.id, getRandomComment('playing', isStrongLead ? 'leadStrong' : 'leadWeak'));
                        } else if (determineObjective(player) === 'MUST_WIN') {
                            showCPUComment(player.id, getRandomComment('playing', 'mustWin'));
                        }
                    }
                    playedDomino = moveChoice.domino;
                    if (trick.length === 0) {
                        trickSuit = getDominoType(playedDomino) === 'trump' ? 'trump' : moveChoice.suitToLead;
                    }
                } else {
                     playedDomino = await getPlayerMove();
                     if (trick.length === 0) {
                        trickSuit = getDominoType(playedDomino) === 'trump' ? 'trump' : await chooseSuit(playedDomino);
                     }
                }
                
                soundManager.play('click');
                player.hand = player.hand.filter(d => d.originalId !== playedDomino.originalId);
                trick.push({ domino: playedDomino, playerIndex: currentPlayerIndex });
                
                roundState.playedDominoes.push(playedDomino.id);
                if (getDominoType(playedDomino) === 'trump') roundState.trumpsPlayed.push(playedDomino.id);
                if (getDominoType(playedDomino) === 'ace') roundState.acesPlayed.push(playedDomino.id);

                currentPlayerIndex = (currentPlayerIndex + 1) % 4;
                updateUI();
                await sleep(500 / autoplaySpeed);
            }
            await sleep(1000 / autoplaySpeed);
            await endTrick();
            resolve();
        });
    }
    
    function chooseSuit(domino) {
        if (domino.pips1 === domino.pips2 && domino.id !== '0-6') {
             return Promise.resolve(domino.pips1);
        }
        return new Promise(resolve => {
            suitModal.classList.remove('hidden');
            const choices = document.getElementById('suit-choice-buttons');
            choices.innerHTML = '';
            const options = (domino.id === '0-6') ? [0, 6] : [domino.pips1, domino.pips2].filter(p => p !== 1 || getDominoType(domino) !== 'trump');
            options.forEach(pips => {
                const btn = document.createElement('button');
                btn.className = 'btn'; btn.textContent = pips;
                btn.onclick = () => { suitModal.classList.add('hidden'); resolve(pips); };
                choices.appendChild(btn);
            });
        });
    }

    function isMoveValid(domino, player) {
        if (!domino) return false;
        if (trick.length === 0) return true; // Can lead anything

        const isDominoTrump = getDominoType(domino) === 'trump';
        const isDominoOnSuit = domino.pips1 === trickSuit || domino.pips2 === trickSuit;

        // Ja prasÄ«ts trumpis
        if (trickSuit === 'trump') {
            const playerHasTrump = player.hand.some(d => getDominoType(d) === 'trump');
            return !playerHasTrump || isDominoTrump;
        }
    
        // PÄrbauda vai spÄ“lÄ“tÄjam ir prasÄ«tais skaitlis (NEIEKÄ»AUJOT trumpjus)
        const playerHasSuit = player.hand.some(d => 
            (d.pips1 === trickSuit || d.pips2 === trickSuit) && getDominoType(d) !== 'trump'
        );
    
        if (playerHasSuit) {
            // Ja ir prasÄ«tais skaitlis, var likt TIKAI parasto kauliÅ†u ar Å¡o skaitli (NE trumpi)
            return isDominoOnSuit && !isDominoTrump;
        }
    
        // Ja NAV prasÄ«tÄ skaitÄ¼a, bet IR trumpis - OBLIGÄ€TI jÄliek trumpis
        const playerHasTrump = player.hand.some(d => getDominoType(d) === 'trump');
        if (playerHasTrump) {
            return isDominoTrump;
        }
    
        // Ja nav ne prasÄ«tÄ, ne trumpja - var likt jebko
        return true;
    }
    
    function getPlayerMove() {
        return new Promise(resolve => {
            const handler = (event) => {
                const dominoEl = event.target.closest('.domino:not(.disabled)');
                if (!dominoEl) return;
                const domino = players[3].hand.find(d => d.originalId === dominoEl.dataset.id);
                if (domino && isMoveValid(domino, players[3])) {
                    document.getElementById('player-hand-3').removeEventListener('click', handler);
                    resolve(domino);
                } else {
                    statusMessage.textContent = translations[currentLanguage].mustFollow;
                    setTimeout(() => { statusMessage.textContent = translations[currentLanguage].playerTurn(players[3].name); }, 2500);
                }
            };
            document.getElementById('player-hand-3').addEventListener('click', handler);
        });
    }

    // HISTORY PANEL UPDATE: Function signature changed
    function determineTrickWinner(currentTrick, suitForTrick) {
        if (!currentTrick || currentTrick.length === 0) return null;
        let highestRank = -1;
        let winnerPlay = null;
        for (const play of currentTrick) {
            const rank = getDominoRank(play.domino, suitForTrick);
            if (rank > highestRank) {
                highestRank = rank;
                winnerPlay = play;
            }
        }
        return winnerPlay;
    }
    
    function endTrick() {
        return new Promise(async resolve => {
            recordTrickHistory(); // Record before determining winner for history UI
            const winnerPlay = determineTrickWinner(trick, trickSuit);
			
            if (winnerPlay) {
                const winner = players[winnerPlay.playerIndex];
                winner.tricksWon++;
                const objective = determineObjective(winner);
                if (objective === 'MUST_WIN' || objective === 'NEED_WIN') {
                    showPlayerEmotion(winner.id, 'happy');
                    if (winner.isCPU) showCPUComment(winner.id, getRandomComment('trickEnd', 'critical'));
                } else if (objective === 'AVOID' || objective === 'AVOID_ALL') {
                    showPlayerEmotion(winner.id, 'shocked');
                    if (winner.isCPU) showCPUComment(winner.id, getRandomComment('trickEnd', 'bad'));
                } else {
                    showPlayerEmotion(winner.id, 'cool');
                    if (winner.isCPU) showCPUComment(winner.id, getRandomComment('trickEnd', 'won'));
                }
    
                trick.forEach(play => {
                    if (play.playerIndex !== winnerPlay.playerIndex) {
                        const loser = players[play.playerIndex];
                        const loserObjective = determineObjective(loser);
                        if (loserObjective === 'MUST_WIN') showPlayerEmotion(loser.id, 'angry');
                        else if (loserObjective === 'AVOID_ALL') showPlayerEmotion(loser.id, 'happy');
                        else showPlayerEmotion(loser.id, 'thinking');
                    }
                });
                currentPlayerIndex = winner.id;
                statusMessage.textContent = translations[currentLanguage].trickWon(winner.name);
                
                const winningDominoContainer = Array.from(tableArea.querySelectorAll('.trick-domino-container')).find(container => 
                    container.querySelector('.domino').dataset.id === winnerPlay.domino.originalId
                );
                if (winningDominoContainer) winningDominoContainer.classList.add('winning-domino');
                
            } else {
                currentPlayerIndex = trickStartIndex; 
            }
            
            updateUI(); // Update UI to show history immediately
            await sleep(2500 / autoplaySpeed);
            resolve();
        });
    }

    function endRound() {
        gameState = 'roundover';
        statusMessage.textContent = translations[currentLanguage].roundOver;
        const roundResultsBody = document.getElementById('round-results-body');
        roundResultsBody.innerHTML = ''; 

        let playerWon = false;
        players.forEach(p => {
            let roundPoints = 0;
            let calculationText = '';

            if (p.bid === p.tricksWon) {
                roundPoints = p.bid * 15;
                if (p.bid === 7) { roundPoints += 30; calculationText = `(7 x 15) + 30 bonuss = ${roundPoints}`; } 
                else { calculationText = `${p.bid} x 15 = ${roundPoints}`; }
            } else {
                if (p.bid === 7) { roundPoints = -30; calculationText = `NeizpildÄ«ts 7 stiÄ·u solÄ«jums = -30`; } 
                else if (p.tricksWon < p.bid) { roundPoints = -5 * (p.bid - p.tricksWon); calculationText = `-5 x ${p.bid - p.tricksWon} nepaÅ†emti = ${roundPoints}`; } 
                else { roundPoints = p.tricksWon * 5; calculationText = `${p.tricksWon} x 5 = ${roundPoints}`; }
            }
            p.score += roundPoints;
            if (p.id === 3 && roundPoints > 0) playerWon = true;

            const pointsClass = roundPoints >= 15 ? 'text-green-400' : (roundPoints > 0 ? 'text-yellow-400' : 'text-red-400');
            const resultRow = document.createElement('div');
            resultRow.className = 'result-row';
            resultRow.innerHTML = `
                <div class="flex justify-between items-center">
                    <span class="player-name">${p.name}</span>
                    <span class="points-calculation ${pointsClass}">${roundPoints >= 0 ? '+' : ''}${roundPoints} ${translations[currentLanguage].pointsSuffix}</span>
                </div>
                <div class="bid-info">${translations[currentLanguage].roundResultText(p.bid, p.tricksWon)}</div>
                <div class="bid-info text-xs italic opacity-80">${calculationText}</div>`;
            roundResultsBody.appendChild(resultRow);
        });
        
        soundManager.play(playerWon ? 'winGame' : 'loseGame');
        updateScoreboard(); 
        roundOverModal.classList.remove('hidden'); 
    }

    function showGameOver() {
        gameState = 'gameover';
        const sortedPlayers = [...players].sort((a,b) => b.score - a.score);
        const winner = sortedPlayers[0];
        
        if (winner.id === 3) gameStats.wins++;
        gameStats.gamesPlayed++;
        gameStats.totalScore += players[3].score;
        saveStats();

        document.getElementById('game-over-winner').textContent = translations[currentLanguage].winnerIs(winner.name, winner.score);
        const finalScoresEl = document.getElementById('final-scores');
        finalScoresEl.innerHTML = `<h4 class="text-lg font-bold mb-2">${translations[currentLanguage].finalScoresTitle}</h4>`;
        sortedPlayers.forEach(p => finalScoresEl.innerHTML += `<p class="flex justify-between"><span>${p.name}:</span> <span>${p.score} ${translations[currentLanguage].pointsSuffix}</span></p>`);
        
        document.getElementById('winner-animation-container').innerHTML = '<div class="winner-cup">ğŸ†</div>';
        gameOverModal.classList.remove('hidden');
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    async function callGemini(prompt) {
        const geminiModalContent = document.getElementById('gemini-modal-content');
        geminiModal.classList.remove('hidden');
        geminiModalContent.innerHTML = `<div class="loader-container flex justify-center items-center"><div class="loader"></div></div>`;
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ role: "user", parts: [{ text: prompt }] }] }) });
            if (!response.ok) throw new Error(`API error: ${response.statusText}`);
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                geminiModalContent.innerHTML = `<p class="whitespace-pre-wrap">${result.candidates[0].content.parts[0].text}</p>`;
            } else { throw new Error("Invalid response structure from API."); }
        } catch (error) {
            console.error("Gemini API call failed:", error);
            geminiModalContent.textContent = "Atvainojiet, radÄs kÄ¼Å«da, sazinoties ar AI padomdevÄ“ju. LÅ«dzu, mÄ“Ä£iniet vÄ“lÄk.";
        }
    }

    function handleGetAdvice() {
        const player = players[3];
        const handString = player.hand.map(d => d.originalId).join(', ');
        const trickString = trick.map(p => `${p.domino.originalId} (spÄ“lÄ“ja ${players[p.playerIndex].name})`).join(', ') || 'nav';
        const prompt = `Esi pasaules klases Domino pokera stratÄ“Ä£ijas eksperts. Tavs mÄ“rÄ·is ir ieteikt cilvÄ“kam labÄko gÄjienu. SpÄ“le lÄ«dzinÄs Zolei vai BridÅ¾am. Trumpji ir Ä¼oti spÄ“cÄ«gi. DÅ«Å¾i (dubultie) arÄ« ir spÄ“cÄ«gi. SpÄ“lÄ“tÄjam ir jÄseko mastam, ja viÅ†Å¡ var. Å Ä« ir paÅ¡reizÄ“jÄ situÄcija:
- Mani kauliÅ†i: [${handString}]
- Es solÄ«ju ${player.bid} un esmu paÅ†Ä“mis ${player.tricksWon} stiÄ·us.
- Citu spÄ“lÄ“tÄju solÄ«jumi: JÄnis (${players[0].bid}), PÄ“teris (${players[1].bid}), Andris (${players[2].bid}).
- Ir mans gÄjiens.
- Å ajÄ stiÄ·Ä« jau nospÄ“lÄ“tie kauliÅ†i: ${trickString}
- Masts, kuram jÄseko: ${trickSuit === null ? 'jebkurÅ¡' : (trickSuit === 'trump' ? 'trumpji' : trickSuit)}.

Pamatojoties uz Å¡o, kurÅ¡ ir labÄkais kauliÅ†Å¡, ko man spÄ“lÄ“t no savas rokas un kÄpÄ“c? Sniedz kodolÄ«gu stratÄ“Ä£isku pamatojumu latvieÅ¡u valodÄ.`;
        document.getElementById('gemini-modal-title').textContent = translations[currentLanguage].adviceTitle;
        callGemini(prompt);
    }
    
    function handleAnalyzeRound() {
        const results = players.map(p => `- SpÄ“lÄ“tÄjs '${p.name}' solÄ«ja ${p.bid}, paÅ†Ä“ma ${p.tricksWon}.`).join('\n');
        const prompt = `Esi asprÄtÄ«gs Domino pokera komentÄ“tÄjs. Äªsi analizÄ“ tikko pabeigto partiju. Esi ieskatu sniedzoÅ¡s un nedaudz izklaidÄ“joÅ¡s. Å eit ir rezultÄti:\n${results}\n\nSniedz Ä«su, vienas rindkopas analÄ«zi par partiju latvieÅ¡u valodÄ. KurÅ¡ bija partijas zvaigzne un kurÅ¡ pieÄ¼Äva lielu kÄ¼Å«du?`;
        document.getElementById('gemini-modal-title').textContent = translations[currentLanguage].analysisTitle;
        callGemini(prompt);
    }
    
    function saveStats() { localStorage.setItem('dominoPokerStats', JSON.stringify(gameStats)); }
    function loadStats() {
        const savedStats = localStorage.getItem('dominoPokerStats');
        if (savedStats) gameStats = JSON.parse(savedStats);
    }
    function showStats() {
        const contentEl = document.getElementById('stats-modal-content');
        document.getElementById('stats-modal-title').textContent = translations[currentLanguage].statsTitle;
        contentEl.innerHTML = `
            <p>${translations[currentLanguage].gamesPlayed}: <span class="stat-value">${gameStats.gamesPlayed}</span></p>
            <p>${translations[currentLanguage].wins}: <span class="stat-value">${gameStats.wins}</span></p>
            <p>${translations[currentLanguage].totalScore}: <span class="stat-value">${gameStats.totalScore}</span></p>`;
        statsModal.classList.remove('hidden');
    }

    function updateAutoplayButton() {
        autoplayBtn.classList.toggle('btn-toggle-on', isPlayerAutoplaying);
        autoplayBtn.textContent = isPlayerAutoplaying ? translations[currentLanguage].disableAutoplay : translations[currentLanguage].enableAutoplay;
    }
    function toggleAutoplay() {
        isPlayerAutoplaying = !isPlayerAutoplaying;
        players[3].name = isPlayerAutoplaying ? `${translations[currentLanguage].you} (CPU)` : translations[currentLanguage].you;
        updateAutoplayButton();
        updatePlayerHandClickability();
    }
    function setAutoplaySpeed(speed) {
        autoplaySpeed = speed;
        document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`speed-${speed}x`).classList.add('active');
    }
    document.getElementById('speed-1x').addEventListener('click', () => setAutoplaySpeed(1));
    document.getElementById('speed-2x').addEventListener('click', () => setAutoplaySpeed(2));
    document.getElementById('speed-3x').addEventListener('click', () => setAutoplaySpeed(3));
    document.getElementById('start-game-btn').addEventListener('click', () => {
        document.getElementById('rounds-modal').classList.add('hidden');
        totalRounds = parseInt(document.getElementById('rounds-input').value) || 5;
        cpuDifficulty = document.getElementById('difficulty-select').value;
        runGame();
    });
    document.getElementById('play-again-btn').addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        document.getElementById('rounds-modal').classList.remove('hidden');
    });
    document.getElementById('next-round-btn').addEventListener('click', () => {
        roundOverModal.classList.add('hidden');
        if (resolveNextRound) resolveNextRound();
    });
    autoplayBtn.addEventListener('click', toggleAutoplay);
    document.getElementById('lang-lv').addEventListener('click', () => setLanguage('lv'));
    document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
    geminiAdviceBtn.addEventListener('click', handleGetAdvice);
    geminiAnalysisBtn.addEventListener('click', handleAnalyzeRound);
    document.getElementById('gemini-modal-close-btn').addEventListener('click', () => geminiModal.classList.add('hidden'));
    helpBtn.addEventListener('click', () => {
        const rulesData = rules[currentLanguage];
        document.getElementById('rules-modal-title').textContent = rulesData.title;
        document.getElementById('rules-modal-content').innerHTML = rulesData.content;
        rulesModal.classList.remove('hidden');
    });
    document.getElementById('rules-modal-close-btn').addEventListener('click', () => rulesModal.classList.add('hidden'));
    statsBtn.addEventListener('click', showStats);
    document.getElementById('stats-modal-close-btn').addEventListener('click', () => statsModal.classList.add('hidden'));
    loadStats();
    setLanguage('lv');

    // --- CPU STRATEGY ---
    function getCPUBid(player) {
        const handStrength = evaluateHandStrength(player.hand);
        let estimatedTricks = 0;
        const myTrumps = player.hand.filter(d => getDominoType(d) === 'trump');
        myTrumps.forEach(t => { estimatedTricks += 0.45 + (0.5 * (trumps.length - trumps.indexOf(t.id)) / trumps.length); });
        player.hand.filter(d => getDominoType(d) === 'ace').forEach(ace => {
            const support = getSuitCount(player.hand, ace.pips1) - 1;
            let prob = 0.2 + (0.3 * (aces.length - aces.indexOf(ace.id)) / aces.length);
            if (support >= 3) prob += 0.5; else if (support === 2) prob += 0.3; else if (support === 1) prob += 0.1;
            if (myTrumps.length === 0) prob -= 0.2; else if (myTrumps.length >= 3) prob += 0.1;
            estimatedTricks += Math.min(0.95, prob);
        });
        
        let bid = Math.round(estimatedTricks);
        if (cpuDifficulty === 'easy') { bid = Math.max(0, bid - 1); if (Math.random() < 0.3) bid += Math.random() < 0.5 ? 1 : -1; } 
        else if (cpuDifficulty === 'hard') {
            if (handStrength > 25 && bid < 3) bid = 3;
            if (myTrumps.length >= 4 && bid < 4) bid = Math.min(4, bid + 1);
        }
        if (bid === 1 && handStrength < 15 && Math.random() < (cpuDifficulty === 'hard' ? 0.4 : 0.2)) bid = 0;
        return Math.max(0, Math.min(7, bid));
    }
    
	function getCPUMove(player) {
        const validMoves = player.hand.filter(d => isMoveValid(d, player));
        if (validMoves.length === 0) return { domino: player.hand[0], suitToLead: player.hand[0].pips1 }; // Fallback
        if (validMoves.length === 1) return { domino: validMoves[0], suitToLead: getDominoType(validMoves[0]) === 'trump' ? 'trump' : validMoves[0].pips1 };
    
        const objective = determineObjective(player);
        const gameContext = {
            trickNumber, remainingTricks: 7 - trickNumber, myTricksNeeded: player.bid - player.tricksWon,
            opponents: players.filter(p => p.id !== player.id), remainingTrumps: countRemainingTrumps(),
            bidAnalysis: analyzeOpponentsBids()
        };
    
        return trick.length === 0 ? makeLeadDecision(player, validMoves, objective, gameContext) : makeFollowDecision(player, validMoves, objective, gameContext);
    }
	
	function makeLeadDecision(player, validMoves, objective, context) {
        let bestMove = null, bestSuit = -1;
        const myTrumps = validMoves.filter(d => getDominoType(d) === 'trump').sort((a,b)=>trumps.indexOf(a.id)-trumps.indexOf(b.id));
        const myAces = validMoves.filter(d => getDominoType(d) === 'ace').sort((a,b)=>aces.indexOf(a.id)-aces.indexOf(b.id));
        const normal = validMoves.filter(d => getDominoType(d) === 'normal');

        if (context.trickNumber === 1 && myAces.length > 0) return { domino: myAces[0], suitToLead: myAces[0].pips1 };
    
        if (objective === 'MUST_WIN' || objective === 'NEED_WIN') {
            if (myTrumps.length > 0 && context.remainingTrumps <= 3) bestMove = myTrumps[0];
            else if (myAces.length > 0) bestMove = myAces[0];
            else if (normal.length > 0) bestMove = selectLongSuitLead(player, normal);
        } else if (objective === 'AVOID_ALL' || objective === 'AVOID') {
            if (normal.length > 0) bestMove = selectShortSuitLead(player, normal);
            else if (myAces.length > 0) bestMove = myAces[myAces.length - 1]; // Weakest ace
            else bestMove = myTrumps[myTrumps.length - 1]; // Weakest trump
        }
        
        if (!bestMove) {
             bestMove = cpuDifficulty === 'hard' ? makeStrategicLead(player, validMoves, context) : (normal.length > 0 ? normal[Math.floor(normal.length/2)] : validMoves[0]);
        }
        
        if (getDominoType(bestMove) !== 'trump') {
            bestSuit = (bestMove.pips1 === bestMove.pips2) ? bestMove.pips1 : (getSuitCount(player.hand, bestMove.pips1) >= getSuitCount(player.hand, bestMove.pips2) ? bestMove.pips1 : bestMove.pips2);
        }
        return { domino: bestMove, suitToLead: bestSuit };
    }

    function makeFollowDecision(player, validMoves, objective, context) {
        const canWin = validMoves.some(m => determineTrickWinner([...trick, { domino: m, playerIndex: player.id }], trickSuit).playerIndex === player.id);
        const trickAnalysis = analyzeTrick();
    
        if (objective === 'MUST_WIN' || objective === 'NEED_WIN') {
            return { domino: canWin ? selectWinningMove(player, validMoves, 'minimal') : selectDiscardMove(player, validMoves, 'save_winners') };
        } else if (objective === 'AVOID_ALL' || objective === 'AVOID') {
            return { domino: !canWin ? selectDiscardMove(player, validMoves, 'dump_winners') : selectWinningMove(player, validMoves, 'minimal') };
        } else { // Flexible
            if (cpuDifficulty === 'hard') return makeStrategicFollow(player, validMoves, context, trickAnalysis);
            return { domino: canWin && Math.random() < 0.6 ? selectWinningMove(player, validMoves, 'balanced') : selectDiscardMove(player, validMoves, 'balanced') };
        }
    }

    function selectLongSuitLead(player, doms) { /* ... */ return doms.sort((a,b) => getSuitCount(player.hand, a.pips1) - getSuitCount(player.hand, b.pips1))[0] || doms[0]; }
    function selectShortSuitLead(player, doms) { /* ... */ return doms.sort((a,b) => (a.pips1 + a.pips2 + getSuitCount(player.hand, a.pips1)*5) - (b.pips1 + b.pips2 + getSuitCount(player.hand, b.pips1)*5))[0] || doms[0]; }
    
    function selectWinningMove(player, moves, strategy) {
        const sorted = moves.filter(m => determineTrickWinner([...trick, { domino: m, playerIndex: player.id }], trickSuit).playerIndex === player.id)
                            .sort((a, b) => getDominoRank(a, trickSuit) - getDominoRank(b, trickSuit));
        if (sorted.length === 0) return selectDiscardMove(player, moves, 'balanced'); // Fallback
        if (strategy === 'minimal') return sorted[0];
        if (strategy === 'maximal') return sorted[sorted.length - 1];
        return sorted[Math.floor(sorted.length / 2)];
    }

    function selectDiscardMove(player, moves, strategy) {
        const nonWinning = moves.filter(m => determineTrickWinner([...trick, { domino: m, playerIndex: player.id }], trickSuit).playerIndex !== player.id);
        const list = nonWinning.length > 0 ? nonWinning : moves;
        const getVal = d => (getDominoType(d) === 'trump' ? 100 : (getDominoType(d) === 'ace' ? 50 : 0)) + d.pips1 + d.pips2;
        if (strategy === 'save_winners') return list.sort((a, b) => getVal(a) - getVal(b))[0];
        if (strategy === 'dump_winners') return list.sort((a, b) => getVal(b) - getVal(a))[0];
        return list[Math.floor(list.length/2)];
    }

    function makeStrategicLead(player, validMoves, context) {
        const dangerousOpponent = context.opponents.find(opp => opp.bid - opp.tricksWon >= context.remainingTricks - 1);
        if (dangerousOpponent) {
            for (let suit = 6; suit >= 0; suit--) {
                if (getPlayerSuitExhaustion(dangerousOpponent.id, suit)) {
                    const move = validMoves.find(d => getDominoType(d) === 'normal' && (d.pips1 === suit || d.pips2 === suit));
                    if (move) return move;
                }
            }
        }
        return validMoves[Math.floor(validMoves.length / 2)];
    }

    function makeStrategicFollow(player, validMoves, context, trickAnalysis) {
        const canWin = validMoves.some(m => determineTrickWinner([...trick, { domino: m, playerIndex: player.id }], trickSuit).playerIndex === player.id);
        const desperateOpponentWinning = context.opponents.find(opp => opp.id === trickAnalysis.expectedWinner && opp.bid - opp.tricksWon === context.remainingTricks);
        if (desperateOpponentWinning && canWin) return { domino: selectWinningMove(player, validMoves, 'minimal') };
        if (canWin && player.tricksWon < player.bid) return { domino: selectWinningMove(player, validMoves, 'minimal') };
        return { domino: selectDiscardMove(player, validMoves, 'balanced') };
    }
});
</script>
</body>
</html>
