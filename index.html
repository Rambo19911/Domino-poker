<!DOCTYPE html>
<html lang="lv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Pokers ar Gemini</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #0f3d1b;
            background-image: radial-gradient(circle at center, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 60%);
            color: #e2e8f0;
            user-select: none;
            overflow-x: hidden;
            padding: 1rem;
        }

        .domino-back {
            background-color: #1a202c;
            background-image: 
                linear-gradient(135deg, #2d3748 25%, transparent 25%), 
                linear-gradient(225deg, #2d3748 25%, transparent 25%),
                linear-gradient(45deg, #2d3748 25%, transparent 25%),
                linear-gradient(315deg, #2d3748 25%, #1a202c 25%);
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 8px 8px;
            background-repeat: repeat;
            border: 2px solid #a0aec0;
        }

        .domino {
            width: 48px; height: 96px; background-color: #f7fafc;
            border: 2px solid #a0aec0; border-radius: 8px;
            display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; padding: 4px; margin: 4px;
            cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }
        .domino:hover:not(.disabled) {
            transform: translateY(-5px) scale(1.05);
            border-color: #f6e05e;
        }
        .domino.disabled { cursor: not-allowed; opacity: 0.6; background-color: #a0aec0; }
        .domino-side { width: 80px; height: 40px; flex-direction: row; }
        .domino-side .domino-half { width: 50%; height: 100%; }
        .domino-side .domino-divider { width: 2px; height: 80%; }
        
        .domino-half {
            width: 100%; height: 50%; display: grid;
            grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            padding: 3px; gap: 1px;
        }
        .domino-divider { width: 80%; height: 2px; background-color: #4a5568; align-self: center; }
        .dot { width: 100%; height: 100%; border-radius: 50%; background-color: #2d3748; transform: scale(0.65); }

        .player-area {
            min-height: 140px; border-radius: 10px; padding: 10px;
            transition: all 0.3s ease; position: relative;
            border: 2px solid transparent;
        }
        .active-player {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: #63b3ed;
            box-shadow: 0 0 20px rgba(99, 179, 237, 0.5);
        }
        
        @keyframes blink-border {
            50% { border-color: #f6e05e; box-shadow: 0 0 20px rgba(246, 224, 94, 0.7); }
        }
        .turn-starter-indicator {
            animation: blink-border 1.5s ease-in-out infinite;
        }
        .active-player.turn-starter-indicator { animation: none; }

        .table-area {
            min-height: 140px; 
            border: 4px ridge #8c6b48; border-radius: 10px;
            display: flex; flex-wrap: wrap; 
            justify-content: center; align-items: center; gap: 8px;
            padding: 10px;
            background-color: #165c2a; box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
        }
        
        .trick-domino-container {
            transition: all 0.5s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .trick-domino-owner {
            font-size: 11px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 1px 4px;
            border-radius: 4px;
            white-space: nowrap;
            margin-top: 2px;
        }
        .winning-domino .domino {
            transform: scale(1.1) !important;
            box-shadow: 0 0 25px 5px #f6e05e;
            border-color: #f6e05e;
            z-index: 10;
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75); display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background-color: #2d3748; padding: 20px 30px 30px 30px; border-radius: 15px;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            border: 1px solid #4a5568; max-width: 90%; width: 600px; position: relative;
        }
        .btn {
            background-color: #4299e1; color: white; padding: 10px 20px;
            border-radius: 8px; border: none; cursor: pointer;
            transition: all 0.2s; font-weight: bold;
        }
        .btn:hover:not(:disabled) { background-color: #3182ce; }
        .btn:disabled { background-color: #a0aec0; cursor: not-allowed; }
        .btn-sm { padding: 5px 10px; font-size: 0.875rem; }
        
        .autoplay-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 8px;
        }
        .speed-btn {
            background-color: #4a5568;
            border: 1px solid #718096;
        }
        .speed-btn.active {
            background-color: #4299e1;
            border-color: #63b3ed;
            color: white;
        }
        .btn-toggle-on { background-color: #e53e3e; } 
        .btn-toggle-on:hover { background-color: #c53030; }

        .winner-cup {
            position: absolute; top: 10px; right: 10px; font-size: 50px;
            animation: cup-pop 0.5s ease-out forwards, cup-glow 2s infinite alternate;
        }
        @keyframes cup-pop { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes cup-glow { from { filter: drop-shadow(0 0 5px #f6e05e); } to { filter: drop-shadow(0 0 15px #f6e05e); } }
        
        .lang-switcher {
            position: absolute; top: 1rem; right: 1rem; display: flex;
            gap: 0.5rem; background-color: rgba(45, 55, 72, 0.7);
            padding: 0.5rem; border-radius: 8px; z-index: 50;
        }
        .lang-btn {
            padding: 0.25rem 0.5rem; border: 1px solid #a0aec0;
            border-radius: 6px; cursor: pointer; transition: all 0.2s; opacity: 0.7;
        }
        .lang-btn.active {
            background-color: #4299e1; border-color: #4299e1; color: white; opacity: 1;
        }
        
        #round-results-body .result-row { padding: 8px; border-bottom: 1px solid #4a5568; }
        #round-results-body .result-row:last-child { border-bottom: none; }
        #round-results-body .player-name { font-weight: bold; font-size: 1.1rem; }
        #round-results-body .bid-info { font-size: 0.9rem; color: #cbd5e0; }
        #round-results-body .points-calculation { font-size: 1.2rem; font-weight: bold; }

        .gemini-btn { background-color: #9f7aea; border-color: #805ad5; }
        .gemini-btn:hover:not(:disabled) { background-color: #805ad5; }
        
        .loader {
            width: 48px; height: 48px; border: 5px solid #FFF;
            border-bottom-color: #9f7aea; border-radius: 50%;
            display: inline-block; box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #help-btn {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 40px;
            height: 40px;
            background-color: rgba(45, 55, 72, 0.7);
            border: 1px solid #a0aec0;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 50;
        }
        #help-btn:hover { background-color: #4a5568; }

        #rules-modal-content {
            text-align: left;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 15px;
        }
        #rules-modal-content h3 { font-size: 1.25rem; font-weight: bold; margin-top: 1rem; margin-bottom: 0.5rem; color: #90cdf4; border-bottom: 1px solid #4a5568; padding-bottom: 0.25rem;}
        #rules-modal-content h4 { font-size: 1.1rem; font-weight: bold; margin-top: 0.75rem; margin-bottom: 0.25rem; }
        #rules-modal-content p, #rules-modal-content li { margin-bottom: 0.5rem; color: #cbd5e0; }
        #rules-modal-content ul { list-style-type: disc; padding-left: 20px; }
    </style>
</head>
<body>
    <button id="help-btn">?</button>

    <div class="lang-switcher">
        <button id="lang-lv" class="lang-btn active">LV</button>
        <button id="lang-en" class="lang-btn">EN</button>
    </div>

    <div id="game-container" class="max-w-screen-xl mx-auto grid grid-cols-1 lg:grid-cols-5 gap-4">
        <div class="lg:col-span-4">
            <div id="player-area-1" class="player-area mb-4">
                <h2 id="player-name-1" class="text-xl font-bold text-center"></h2>
                <div id="player-hand-1" class="flex justify-center flex-wrap"></div>
                <div class="text-center mt-2 text-sm sm:text-base">
                    <span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-1">?</span> |
                    <span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-1">0</span>
                </div>
            </div>

            <div class="flex justify-between items-center space-x-2 sm:space-x-4">
                <div id="player-area-0" class="player-area w-1/4 sm:w-1/5">
                    <h2 id="player-name-0" class="text-xl font-bold text-center"></h2>
                    <div id="player-hand-0" class="flex flex-wrap justify-center"></div>
                     <div class="text-center mt-2 text-sm sm:text-base">
                        <p><span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-0">?</span></p>
                        <p><span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-0">0</span></p>
                    </div>
                </div>

                <div class="w-1/2 sm:w-3/5">
                    <div id="game-info" class="text-center mb-2">
                        <h1 class="text-2xl sm:text-3xl font-bold">Domino Pokers</h1>
                        <p id="status-message" class="text-lg h-8"></p>
                        <p class="text-xs sm:text-sm"><span data-lang-key="round">Partija</span>: <span id="round-number">1</span>/<span id="total-rounds">5</span></p>
                    </div>
                    <div id="table-area" class="table-area">
                        <div id="bidding-controls" class="hidden"></div>
                    </div>
                     <div id="suit-info" class="text-center mt-2 h-6 font-bold"></div>
                </div>

                 <div id="player-area-2" class="player-area w-1/4 sm:w-1/5">
                    <h2 id="player-name-2" class="text-xl font-bold text-center"></h2>
                    <div id="player-hand-2" class="flex flex-wrap justify-center"></div>
                     <div class="text-center mt-2 text-sm sm:text-base">
                        <p><span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-2">?</span></p>
                        <p><span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-2">0</span></p>
                    </div>
                </div>
            </div>

            <div id="player-area-3" class="player-area mt-4">
                <div class="absolute top-2 right-2 flex items-center gap-2">
                    <div class="autoplay-controls">
                        <button id="autoplay-btn" class="btn btn-sm"></button>
                    </div>
                    <div class="autoplay-controls">
                        <span class="text-xs font-bold" data-lang-key="speed">Ä€trums:</span>
                        <button id="speed-1x" class="btn btn-sm speed-btn active">1x</button>
                        <button id="speed-2x" class="btn btn-sm speed-btn">2x</button>
                        <button id="speed-3x" class="btn btn-sm speed-btn">3x</button>
                    </div>
                </div>
                <h2 id="player-name-3" class="text-xl font-bold text-center" data-lang-key="you">JÅ«s</h2>
                <div id="player-controls" class="text-center my-2">
                     <button id="gemini-advice-btn" class="btn btn-sm gemini-btn hidden">âœ¨ <span data-lang-key="getAdvice">GÄjiena ieteikums</span></button>
                </div>
                <div id="player-hand-3" class="flex justify-center flex-wrap"></div>
                 <div class="text-center mt-2 text-sm sm:text-base">
                    <span data-lang-key="bid">SolÄ«ja</span>: <span id="player-bid-3">?</span> |
                    <span data-lang-key="taken">PaÅ†Ä“ma</span>: <span id="player-tricks-3">0</span>
                </div>
            </div>
        </div>
        
        <div class="lg:col-span-1">
            <div class="sticky top-4">
                <div id="scoreboard" class="scoreboard">
                    <h2 class="text-2xl font-bold mb-4 text-center" data-lang-key="scoreboard">RezultÄti</h2>
                    <div id="scoreboard-body" class="space-y-1"></div>
                </div>
                <div id="history-panel" class="mt-4">
                    <h3 class="text-xl font-bold mb-2 text-center" data-lang-key="lastTrick">PÄ“dÄ“jais StiÄ·is</h3>
                    <div id="history-body" class="flex flex-wrap justify-center gap-1 bg-slate-700/50 p-2 rounded min-h-[80px] items-center"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="rounds-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl mb-4" data-lang-key="howManyRounds">Cik partijas spÄ“lÄ“siet?</h2>
            <input type="number" id="rounds-input" class="bg-gray-700 text-white p-2 rounded w-full mb-4" value="5" min="1" max="20">
            <button id="start-game-btn" class="btn" data-lang-key="startGame">SÄkt spÄ“li</button>
        </div>
    </div>
        
    <div id="suit-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl mb-4" data-lang-key="chooseSuitLead">Ar kuru skaitli sÄkt gÄjienu?</h2>
            <div id="suit-choice-buttons" class="flex justify-center space-x-2"></div>
        </div>
    </div>

    <div id="round-over-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4" data-lang-key="roundResults">Punktu AprÄ“Ä·ins</h2>
            <div id="round-results-body" class="mb-6 text-left space-y-2"></div>
            <div class="flex justify-center gap-4">
                <button id="next-round-btn" class="btn" data-lang-key="continue">TurpinÄt</button>
                <button id="gemini-analysis-btn" class="btn gemini-btn">âœ¨ <span data-lang-key="analyzeRound">AnalizÄ“t partiju</span></button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal hidden">
        <div class="modal-content">
            <div id="winner-animation-container"></div>
            <h2 id="game-over-title" class="text-3xl font-bold mb-4" data-lang-key="gameOver">SpÄ“le Beigusies!</h2>
            <p id="game-over-winner" class="text-xl mb-4"></p>
            <div id="final-scores" class="mb-6 text-left"></div>
            <button id="play-again-btn" class="btn" data-lang-key="playAgain">SpÄ“lÄ“t vÄ“lreiz</button>
        </div>
    </div>

    <div id="gemini-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="gemini-modal-title" class="text-2xl font-bold mb-4">Gemini padoms</h2>
            <div id="gemini-modal-content" class="mb-6 text-left space-y-2 min-h-[100px]">
                 <div class="loader-container flex justify-center items-center">
                    <div class="loader"></div>
                 </div>
            </div>
            <button id="gemini-modal-close-btn" class="btn">AizvÄ“rt</button>
        </div>
    </div>
    
    <div id="rules-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="rules-modal-title" class="text-2xl font-bold mb-4">Noteikumi</h2>
            <div id="rules-modal-content" class="mb-6"></div>
            <button id="rules-modal-close-btn" class="btn">AizvÄ“rt</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE & CONSTANTS ---
    const players = [
        { id: 0, name: 'JÄnis', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 1, name: 'PÄ“teris', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 2, name: 'Andris', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: true },
        { id: 3, name: 'JÅ«s', hand: [], bid: null, tricksWon: 0, score: 0, isCPU: false },
    ];
    let totalRounds = 5, currentRound = 0, dealerIndex = Math.floor(Math.random() * 4);
    let currentPlayerIndex, trickStartIndex, trick = [], lastTrick = [], trickSuit = null, trickNumber = 0;
    let isPlayerAutoplaying = false;
    let autoplaySpeed = 1;
    let gameState = 'setup';
    let roundState = {};
    let resolveNextRound;

    const allDominoes = [];
    for (let i = 0; i <= 6; i++) {
        for (let j = i; j <= 6; j++) {
            allDominoes.push({ pips1: i, pips2: j, id: [i, j].sort().join('-'), originalId: `${i}-${j}` });
        }
    }
    const trumps = ['0-0', '1-1', '1-6', '1-5', '1-4', '1-3', '1-2', '0-1'];
    const aces = ['6-6', '5-5', '4-4', '3-3', '2-2', '0-6'];
    
    // --- UI ELEMENTS ---
    const statusMessage = document.getElementById('status-message'), tableArea = document.getElementById('table-area'),
          suitInfo = document.getElementById('suit-info'), suitModal = document.getElementById('suit-modal'), 
          gameOverModal = document.getElementById('game-over-modal'), scoreboardBody = document.getElementById('scoreboard-body'), 
          roundOverModal = document.getElementById('round-over-modal'), autoplayBtn = document.getElementById('autoplay-btn'),
          historyBody = document.getElementById('history-body'),
          geminiAdviceBtn = document.getElementById('gemini-advice-btn'),
          geminiAnalysisBtn = document.getElementById('gemini-analysis-btn'),
          geminiModal = document.getElementById('gemini-modal'),
          rulesModal = document.getElementById('rules-modal'),
          helpBtn = document.getElementById('help-btn');

    // --- RULES & TRANSLATIONS ---
    const rules = {
        lv: {
            title: "Domino Pokera Noteikumi",
            content: `
                <h3>SpÄ“les MÄ“rÄ·is</h3>
                <p>Domino pokers ir individuÄla domino spÄ“le, kurÄ Äetri spÄ“lÄ“tÄji vÄc punktus, precÄ«zi paÅ†emot iepriekÅ¡ solÄ«tos stiÄ·us. Galvenais mÄ“rÄ·is ir sasniegt pÄ“c iespÄ“jas vairÄk punktu, pÄrdomÄti plÄnojot un taktiski izjaucot pretinieku plÄnus.</p>
                <h3>SpÄ“les Gaita</h3>
                <h4>1. MaisÄ«Å¡ana un VilkÅ¡ana</h4>
                <p>Katrs spÄ“lÄ“tÄjs saÅ†em 7 domino kauliÅ†us no samaisÄ«ta 28 kauliÅ†u komplekta.</p>
                <h4>2. SolÄ«Å¡ana</h4>
                <p>Katrs spÄ“lÄ“tÄjs pÄ“c kÄrtas nosola, cik stiÄ·us viÅ†Å¡ plÄno iegÅ«t (no 0 lÄ«dz 7). SolÄ«Å¡ana notiek vienÄ aplÄ«.</p>
                <h4>3. IzspÄ“le</h4>
                <p>SpÄ“lÄ“tÄjs, kurÅ¡ sÄk, var likt jebkuru kauliÅ†u. PÄrÄ“jiem spÄ“lÄ“tÄjiem ir jÄseko mastam (jÄliek kauliÅ†Å¡ ar tÄdu paÅ¡u ciparu), ja tas ir iespÄ“jams. Ja mastam sekot nevar, drÄ«kst likt trumpi vai atmest jebkuru citu kauliÅ†u.</p>
                <h4>Trumpju secÄ«ba (no spÄ“cÄ«gÄkÄ):</h4>
                <ul><li>0-0, 1-1, 1-6, 1-5, 1-4, 1-3, 1-2, 1-0</li></ul>
                <h4>DÅ«Å¾u secÄ«ba (no spÄ“cÄ«gÄkÄ):</h4>
                <ul><li>6-6, 5-5, 4-4, 3-3, 2-2, 0-6. (Izejot ar 0-6, spÄ“lÄ“tÄjs var izvÄ“lÄ“ties, vai prasÄ«t '0' vai '6' mastu).</li></ul>
                <h3>Punktu skaitÄ«Å¡ana</h3>
                <ul>
                    <li><b>+15 punkti</b> par katru precÄ«zi paÅ†emtu stiÄ·i (ja solÄ«ji 3 un paÅ†Ä“mi 3, saÅ†em 45 punktus).</li>
                    <li><b>+5 punkti</b> par katru stiÄ·i virs solÄ«tÄ (ja solÄ«ji 2 un paÅ†Ä“mi 4, saÅ†em 4*5=20 punktus).</li>
                    <li><b>-5 punkti</b> par katru nepaÅ†emto stiÄ·i lÄ«dz solÄ«tajam (ja solÄ«ji 4 un paÅ†Ä“mi 2, saÅ†em -10 punktus).</li>
                    <li><b>+30 bonusa punkti</b>, ja precÄ«zi paÅ†emti visi 7 solÄ«tie stiÄ·i (kopÄ 7*15+30=135 punkti).</li>
                    <li><b>-30 punkti</b>, ja solÄ«ti visi 7, bet nav paÅ†emti.</li>
                </ul>`
        },
        en: {
            title: "Domino Poker Rules",
            content: `
                <h3>Game Objective</h3>
                <p>Domino Poker is an individual domino game for four players who aim to score points by accurately taking previously bid tricks. Strategic planning and interference with opponents are essential for winning.</p>
                <h3>Gameplay</h3>
                <h4>1. Shuffling and Drawing</h4>
                <p>Each player draws 7 dominoes from a shuffled 28-tile set.</p>
                <h4>2. Bidding</h4>
                <p>Each player bids in turn how many tricks they plan to take (from 0 to 7). There is only one round of bidding.</p>
                <h4>3. Play</h4>
                <p>The lead player can play any tile. Other players must follow suit (play a tile with the same number) if they can. If you cannot follow suit, you may play a trump or discard any other tile.</p>
                <h4>Trump order (highest first):</h4>
                <ul><li>0-0, 1-1, 1-6, 1-5, 1-4, 1-3, 1-2, 1-0</li></ul>
                <h4>Ace order (highest first):</h4>
                <ul><li>6-6, 5-5, 4-4, 3-3, 2-2, 0-6. (When leading with 0-6, the player can choose to call for either the '0' or '6' suit).</li></ul>
                <h3>Scoring</h3>
                <ul>
                    <li><b>+15 points</b> for each trick taken if the bid was met exactly (e.g., bid 3, took 3 = 45 points).</li>
                    <li><b>+5 points</b> for each trick taken if the bid was exceeded (e.g., bid 2, took 4 = 20 points).</li>
                    <li><b>-5 points</b> for each trick missed below the bid (e.g., bid 4, took 2 = -10 points).</li>
                    <li><b>+30 bonus points</b> for bidding and taking all 7 tricks (total 7*15+30=135 points).</li>
                    <li><b>-30 points</b> for bidding 7 tricks but failing to take them all.</li>
                </ul>`
        }
    };
    
    let currentLanguage = 'lv';
    const translations = {
        lv: {
            you: 'JÅ«s', bid: 'SolÄ«ja', taken: 'PaÅ†Ä“ma', round: 'Partija', scoreboard: 'RezultÄti', howManyRounds: 'Cik partijas spÄ“lÄ“siet?',
            startGame: 'SÄkt spÄ“li', chooseSuitLead: 'Ar kuru skaitli sÄkt gÄjienu?', roundResults: 'Punktu AprÄ“Ä·ins', continue: 'TurpinÄt',
            gameOver: 'SpÄ“le Beigusies!', playAgain: 'SpÄ“lÄ“t vÄ“lreiz', mustFollow: 'NederÄ«gs gÄjiens! JÄseko mastam vai jÄliek trumpis.',
            playerTurn: (name) => `${name} gÄjiens...`, bidding: (name) => `${name} solÄ«s...`, bidMade: (name, bid) => `${name} sola ${bid}`,
            gameStarts: (name) => `SpÄ“le sÄkas! ${name} sÄk.`, trickWon: (name) => `${name} paÅ†em stiÄ·i!`, roundOver: 'Partija beigusies! Skaita punktus...',
            shuffling: 'Maisa kauliÅ†us...', bidPrompt: 'Cik stiÄ·us jÅ«s solÄ«siet?',
            winnerIs: (name, score) => `UzvarÄ“tÄjs ir ${name} ar ${score} punktiem!`, finalScoresTitle: 'Gala RezultÄti:', points: 'punkti',
            roundResultText: (bid, taken) => `SolÄ«ja ${bid}, PaÅ†Ä“ma ${taken}`, pointsSuffix: 'punkti', suitLead: (suit) => `JÄseko: ${suit}`,
            trumpSuit: 'Trumpji', enableAutoplay: 'IeslÄ“gt CPU', disableAutoplay: 'IzslÄ“gt CPU',
            lastTrick: 'PÄ“dÄ“jais StiÄ·is', noHistory: 'VÄ“l nav nospÄ“lÄ“ts neviens stiÄ·is.', speed: 'Ä€trums:',
            getAdvice: 'GÄjiena ieteikums', analyzeRound: 'AnalizÄ“t partiju', adviceTitle: 'Gemini padoms', analysisTitle: 'Gemini analÄ«ze'
        },
        en: {
            you: 'You', bid: 'Bid', taken: 'Taken', round: 'Round', scoreboard: 'Scoreboard', howManyRounds: 'How many rounds to play?',
            startGame: 'Start Game', chooseSuitLead: 'Which number to lead with?', roundResults: 'Point Calculation', continue: 'Continue',
            gameOver: 'Game Over!', playAgain: 'Play Again', mustFollow: 'Invalid move! You must follow suit or play a trump.',
            playerTurn: (name) => `${name}'s turn...`, bidding: (name) => `${name} is bidding...`, bidMade: (name, bid) => `${name} bids ${bid}`,
            gameStarts: (name) => `The game begins! ${name} starts.`, trickWon: (name) => `${name} takes the trick!`, roundOver: 'Round over! Calculating scores...',
            shuffling: 'Shuffling dominoes...', bidPrompt: 'How many tricks will you bid?',
            winnerIs: (name, score) => `The winner is ${name} with ${score} points!`, finalScoresTitle: 'Final Scores:', points: 'points',
            roundResultText: (bid, taken) => `Bid ${bid}, Took ${taken}`, pointsSuffix: 'points', suitLead: (suit) => `Suit to follow: ${suit}`,
            trumpSuit: 'Trumps', enableAutoplay: 'Enable CPU', disableAutoplay: 'Disable CPU',
            lastTrick: 'Last Trick', noHistory: 'No tricks played yet.', speed: 'Speed:',
            getAdvice: 'Get Advice', analyzeRound: 'Analyze Round', adviceTitle: 'Gemini Advice', analysisTitle: 'Gemini Analysis'
        }
    };

    function setLanguage(lang) {
        currentLanguage = lang;
        document.documentElement.lang = lang;
        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.dataset.langKey;
            const translation = translations[lang][key];
            if (translation) {
                const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
                if (textNode) {
                    textNode.textContent = ' ' + translation;
                } else if (el.querySelector('span')) {
                    el.querySelector('span').textContent = ' ' + translation;
                }
                 else {
                    el.textContent = translation;
                }
            }
        });
        if (!isPlayerAutoplaying) players[3].name = translations[lang].you;
        document.getElementById('lang-lv').classList.toggle('active', lang === 'lv');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en');
        updateAutoplayButton(); 
        updateUI(); 
    }

    // --- DOMINO & GAME LOGIC ---
    function getDominoType(domino) {
        if (!domino) return 'normal';
        if (trumps.includes(domino.id)) return 'trump';
        if (aces.includes(domino.id)) return 'ace';
        return 'normal';
    }
    
    function getDominoRank(domino, currentTrickSuit) {
        if (!domino) return 0;
        const type = getDominoType(domino);

        if (type === 'trump') {
            return 30 + trumps.length - trumps.indexOf(domino.id);
        }

        if (currentTrickSuit !== null && currentTrickSuit !== 'trump') {
            const hasSuit = domino.pips1 === currentTrickSuit || domino.pips2 === currentTrickSuit;
            if (hasSuit) {
                if (type === 'ace' && domino.pips1 === domino.pips2) {
                    return 20 + domino.pips1;
                }
                const otherPip = domino.pips1 === currentTrickSuit ? domino.pips2 : domino.pips1;
                return 10 + otherPip;
            } else {
                return 0;
            }
        }
        
        if (type === 'ace') {
            return 20 + aces.length - aces.indexOf(domino.id);
        }
        return Math.max(domino.pips1, domino.pips2);
    }

    function createPips(container, count) {
        container.innerHTML = '';
        const pipsLayout = { 1:['5'], 2:['1','9'], 3:['1','5','9'], 4:['1','3','7','9'], 5:['1','3','5','7','9'], 6:['1','3','4','6','7','9'] };
        if (pipsLayout[count]) {
            pipsLayout[count].forEach(pos => {
                const dot = document.createElement('div'); dot.className = 'dot';
                dot.style.gridArea = `${Math.ceil(parseInt(pos)/3)}/${((parseInt(pos)-1)%3)+1}`;
                container.appendChild(dot);
            });
        }
    }

    function createDominoElement(domino, isFaceDown = false, isSidePlayer = false) {
        const dominoEl = document.createElement('div');
        dominoEl.className = 'domino';
        if (isSidePlayer) dominoEl.classList.add('domino-side');
        if (domino) dominoEl.dataset.id = domino.originalId;

        if (isFaceDown) {
            dominoEl.classList.add('domino-back');
            return dominoEl;
        }

        const half1 = document.createElement('div'); half1.className = 'domino-half'; createPips(half1, domino.pips1);
        const divider = document.createElement('div'); divider.className = 'domino-divider';
        const half2 = document.createElement('div'); half2.className = 'domino-half'; createPips(half2, domino.pips2);

        dominoEl.append(half1, divider, half2);
        return dominoEl;
    }
    
    // --- UI UPDATES ---
    function updateUI() {
        players.forEach((player, index) => {
            const handEl = document.getElementById(`player-hand-${index}`),
                  bidEl = document.getElementById(`player-bid-${index}`),
                  tricksEl = document.getElementById(`player-tricks-${index}`),
                  playerAreaEl = document.getElementById(`player-area-${index}`);
            document.getElementById(`player-name-${index}`).textContent = player.name;
            
            playerAreaEl.classList.toggle('active-player', index === currentPlayerIndex && gameState !== 'setup' && gameState !== 'bidding');
            
            const isTurnStarter = index === trickStartIndex && (gameState === 'bidding' || (gameState === 'playing' && trick.length === 0));
            playerAreaEl.classList.toggle('turn-starter-indicator', isTurnStarter);

            const isSide = index === 0 || index === 2;
            handEl.innerHTML = '';
            const showHand = index === 3 || !player.isCPU;
            player.hand.sort((a,b) => getDominoRank(b, null) - getDominoRank(a, null)).forEach(d => {
                const dominoEl = createDominoElement(d, !showHand, isSide);
                handEl.appendChild(dominoEl);
            });
            bidEl.textContent = player.bid === null ? '?' : player.bid;
            tricksEl.textContent = player.tricksWon;
        });

        tableArea.querySelectorAll('.trick-domino-container, #bidding-controls').forEach(el => el.remove());
        
        if (gameState === 'bidding' && currentPlayerIndex === 3 && !isPlayerAutoplaying) {
            getPlayerBid(); 
        }

        trick.forEach((play) => {
            const container = document.createElement('div');
            container.className = 'trick-domino-container';
            
            const dominoEl = createDominoElement(play.domino);
            dominoEl.style.transform = 'scale(0.85)';
            container.appendChild(dominoEl);
            
            const ownerEl = document.createElement('div');
            ownerEl.className = 'trick-domino-owner';
            ownerEl.textContent = players[play.playerIndex].name;
            container.appendChild(ownerEl);
            
            tableArea.appendChild(container);
        });

        document.getElementById('round-number').textContent = currentRound > 0 ? currentRound : 1;
        document.getElementById('total-rounds').textContent = totalRounds;
        suitInfo.textContent = trickSuit !== null && trickSuit !== 'trump' ? `${translations[currentLanguage].suitLead(trickSuit)}` : (trickSuit === 'trump' ? translations[currentLanguage].trumpSuit : '');
        
        geminiAdviceBtn.classList.toggle('hidden', !(gameState === 'playing' && currentPlayerIndex === 3 && !isPlayerAutoplaying));

        updatePlayerHandClickability();
        updateScoreboard();
        updateHistoryUI();
    }
    
    function updateScoreboard() {
        scoreboardBody.innerHTML = '';
        const sortedPlayers = [...players].sort((a,b) => b.score - a.score);
        sortedPlayers.forEach((player, idx) => {
            const playerRow = document.createElement('div');
            playerRow.className = `flex justify-between items-center p-2 rounded ${idx === 0 ? 'bg-yellow-600/30' : 'bg-slate-700/50'}`;
            playerRow.innerHTML = `<span class="font-bold">${idx + 1}. ${player.name}</span><span class="text-lg">${player.score}</span>`;
            scoreboardBody.appendChild(playerRow);
        });
    }

    function updateHistoryUI() {
        historyBody.innerHTML = '';
        if (lastTrick.length === 0) {
            historyBody.textContent = translations[currentLanguage].noHistory;
            return;
        }
        const winnerPlay = determineTrickWinner(lastTrick);
        lastTrick.forEach(play => {
            const dominoEl = createDominoElement(play.domino);
            dominoEl.style.transform = 'scale(0.45)';
            dominoEl.style.margin = '1px';
            if (winnerPlay && play.playerIndex === winnerPlay.playerIndex) {
                dominoEl.style.borderColor = '#f6e05e';
                dominoEl.style.borderWidth = '3px';
            }
            historyBody.appendChild(dominoEl);
        });
    }

    function updatePlayerHandClickability() {
        const isPlayerTurn = currentPlayerIndex === 3 && gameState === 'playing' && !isPlayerAutoplaying;
        const handElements = document.querySelectorAll('#player-hand-3 .domino');
        handElements.forEach(el => {
            const domino = players[3].hand.find(d => d.originalId === el.dataset.id);
            const isValid = isMoveValid(domino, players[3]);
            el.classList.toggle('disabled', !isPlayerTurn || !isValid);
        });
    }

    /**
     * UZLABOJUMS: Pievienots Fisher-Yates jaukÅ¡anas algoritms.
     * Å Ä« funkcija sajauc masÄ«va elementus patiesi nejauÅ¡Ä secÄ«bÄ.
     * @param {Array} array - MasÄ«vs, kas jÄsajauc.
     */
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            // IzvÄ“las nejauÅ¡u indeksu no 0 lÄ«dz i
            const j = Math.floor(Math.random() * (i + 1));
            // Apmaina elementus vietÄm
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    
    // --- GAME FLOW ---
    async function runGame() {
        const cpuNames = { lv: ["JÄnis", "PÄ“teris", "Andris", "MÄris"], en: ["John", "Peter", "Andrew", "Maris"] };
        const names = cpuNames[currentLanguage].sort(() => 0.5 - Math.random());
        players.filter(p => p.isCPU).forEach((p, i) => p.name = names[i]);
        currentRound = 0;
        players.forEach(p => p.score = 0);
        isPlayerAutoplaying = false; updateAutoplayButton();
        
        while(currentRound < totalRounds) {
            currentRound++;
            roundOverModal.classList.add('hidden');
            await startRound();
        }
        showGameOver();
    }
    
    function startRound() {
        return new Promise(async roundResolve => {
            resolveNextRound = roundResolve; 
            
            gameState = 'bidding';
            statusMessage.textContent = translations[currentLanguage].shuffling;
            trickNumber = 0; trick = []; trickSuit = null;
            roundState = { playedDominoes: [], suitsPlayed: { 0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0 } };

            tableArea.innerHTML = '';
            suitInfo.textContent = '';
            
            players.forEach(p => { p.hand = []; p.bid = null; p.tricksWon = 0; });
            
            // UZLABOJUMS: Izmanto Fisher-Yates jaukÅ¡anas algoritmu
            const shuffledDominoes = [...allDominoes];
            shuffleArray(shuffledDominoes);

            for(let i = 0; i < 28; i++) {
                players[i % 4].hand.push(shuffledDominoes[i]);
            }
            
            dealerIndex = (dealerIndex + 1) % 4;
            currentPlayerIndex = (dealerIndex + 1) % 4;
            trickStartIndex = currentPlayerIndex;
            updateUI();
            
            await sleep(1000);
            await startBidding();
            
            gameState = 'playing';
            while(trickNumber < 7) {
                await playTrick();
            }
            endRound();
        });
    }
    
    async function startBidding() {
        for (let i = 0; i < 4; i++) {
            const player = players[currentPlayerIndex];
            statusMessage.textContent = translations[currentLanguage].bidding(player.name);
            players.forEach(p => document.getElementById(`player-area-${p.id}`).classList.remove('active-player'));
            document.getElementById(`player-area-${player.id}`).classList.add('active-player');
            
            const isAutoplaying = player.id === 3 && isPlayerAutoplaying;
            if (player.isCPU || isAutoplaying) {
                player.bid = getCPUBid(player);
                await sleep(1200 / autoplaySpeed);
            } else {
                player.bid = await getPlayerBid();
            }
            
            tableArea.querySelector('#bidding-controls')?.remove();
            statusMessage.textContent = translations[currentLanguage].bidMade(player.name, player.bid);
            updateUI();
            await sleep(500 / autoplaySpeed);
            
            currentPlayerIndex = (currentPlayerIndex + 1) % 4;
        }
        players.forEach(p => document.getElementById(`player-area-${p.id}`).classList.remove('active-player'));
        currentPlayerIndex = trickStartIndex;
        statusMessage.textContent = translations[currentLanguage].gameStarts(players[currentPlayerIndex].name);
        updateUI();
        await sleep(1500 / autoplaySpeed);
    }

    function getPlayerBid() {
        return new Promise(resolve => {
            let biddingControls = document.getElementById('bidding-controls');
            if (!biddingControls) {
                biddingControls = document.createElement('div');
                biddingControls.id = 'bidding-controls';
                tableArea.appendChild(biddingControls);
            }
            
            statusMessage.textContent = translations[currentLanguage].bidPrompt;
            biddingControls.innerHTML = '';
            biddingControls.classList.remove('hidden');
            for(let i = 0; i <= 7; i++) {
                const btn = document.createElement('button');
                btn.className = 'btn m-1'; btn.textContent = i;
                btn.onclick = () => {
                    biddingControls.classList.add('hidden');
                    resolve(i);
                };
                biddingControls.appendChild(btn);
            }
        });
    }

    function playTrick() {
        return new Promise(async resolve => {
            trick = []; trickSuit = null;
            trickNumber++;
            trickStartIndex = currentPlayerIndex;
            updateUI();

            for (let i = 0; i < 4; i++) {
                const player = players[currentPlayerIndex];
                statusMessage.textContent = translations[currentLanguage].playerTurn(player.name);
                updateUI();
                
                let playedDomino;
                const isAutoplaying = player.id === 3 && isPlayerAutoplaying;

                if (player.isCPU || isAutoplaying) {
                    await sleep((isPlayerAutoplaying ? 800 : 1500) / autoplaySpeed);
                    const moveChoice = getCPUMove(player);
                    playedDomino = moveChoice.domino;
                    if (trick.length === 0) {
                        trickSuit = getDominoType(playedDomino) === 'trump' ? 'trump' : moveChoice.suitToLead;
                    }
                } else {
                     playedDomino = await getPlayerMove();
                     if (trick.length === 0) {
                        trickSuit = getDominoType(playedDomino) === 'trump' ? 'trump' : await chooseSuit(playedDomino);
                     }
                }
                
                player.hand = player.hand.filter(d => d.originalId !== playedDomino.originalId);
                trick.push({ domino: playedDomino, playerIndex: currentPlayerIndex });
                
                roundState.playedDominoes.push(playedDomino.id);
                roundState.suitsPlayed[playedDomino.pips1]++;
                if (playedDomino.pips1 !== playedDomino.pips2) roundState.suitsPlayed[playedDomino.pips2]++;

                currentPlayerIndex = (currentPlayerIndex + 1) % 4;
                updateUI();
                await sleep(500 / autoplaySpeed);
            }
            await sleep(1000 / autoplaySpeed);
            await endTrick();
            resolve();
        });
    }
    
    function chooseSuit(domino) {
        const isDouble = domino.pips1 === domino.pips2;
        const canChoose = !isDouble || domino.id === '0-6';
        if (!canChoose) return Promise.resolve(domino.pips1);
        
        return new Promise(resolve => {
            suitModal.classList.remove('hidden');
            const choices = document.getElementById('suit-choice-buttons');
            choices.innerHTML = '';
            const options = (domino.id === '0-6') ? [0, 6] : [domino.pips1, domino.pips2];

            options.forEach(pips => {
                const btn = document.createElement('button');
                btn.className = 'btn'; btn.textContent = pips;
                btn.onclick = () => { suitModal.classList.add('hidden'); resolve(pips); };
                choices.appendChild(btn);
            });
        });
    }

    function isMoveValid(domino, player) {
        if (!domino) return false;
        if (trick.length === 0) return true;

        const hasDominoTheSuit = domino.pips1 === trickSuit || domino.pips2 === trickSuit;
        
        if (trickSuit !== 'trump') {
            const playerHasSuit = player.hand.some(d => d.pips1 === trickSuit || d.pips2 === trickSuit);
            return !playerHasSuit || hasDominoTheSuit;
        } else {
            const playerHasTrump = player.hand.some(d => getDominoType(d) === 'trump');
            return !playerHasTrump || getDominoType(domino) === 'trump';
        }
    }
    
    function getPlayerMove() {
        return new Promise(resolve => {
            const handler = (event) => {
                const dominoEl = event.target.closest('.domino:not(.disabled)');
                if (!dominoEl) return;
                const domino = players[3].hand.find(d => d.originalId === dominoEl.dataset.id);
                if (domino && isMoveValid(domino, players[3])) {
                    document.getElementById('player-hand-3').removeEventListener('click', handler);
                    resolve(domino);
                } else {
                    statusMessage.textContent = translations[currentLanguage].mustFollow;
                    setTimeout(() => { statusMessage.textContent = translations[currentLanguage].playerTurn(players[3].name); }, 2500);
                }
            };
            document.getElementById('player-hand-3').addEventListener('click', handler);
        });
    }

    function determineTrickWinner(currentTrick) {
        if (!currentTrick || currentTrick.length === 0) return null;
        let highestRank = -1;
        let winnerPlay = null;
        for (const play of currentTrick) {
            const rank = getDominoRank(play.domino, trickSuit);
            if (rank > highestRank) {
                highestRank = rank;
                winnerPlay = play;
            }
        }
        return winnerPlay;
    }
    
    function endTrick() {
        return new Promise(async resolve => {
            const winnerPlay = determineTrickWinner(trick);
            if (winnerPlay) {
                const winner = players[winnerPlay.playerIndex];
                winner.tricksWon++;
                currentPlayerIndex = winner.id;
                statusMessage.textContent = translations[currentLanguage].trickWon(winner.name);
                
                const winningDominoContainer = Array.from(tableArea.querySelectorAll('.trick-domino-container')).find(container => 
                    container.querySelector('.domino').dataset.id === winnerPlay.domino.originalId
                );
                if (winningDominoContainer) winningDominoContainer.classList.add('winning-domino');
                
            } else {
                currentPlayerIndex = trickStartIndex; 
            }
            lastTrick = [...trick];
            updateUI();
            await sleep(2500 / autoplaySpeed);
            resolve();
        });
    }

    function endRound() {
        gameState = 'roundover';
        statusMessage.textContent = translations[currentLanguage].roundOver;
        const roundResultsBody = document.getElementById('round-results-body');
        roundResultsBody.innerHTML = ''; 

        players.forEach(p => {
            let roundPoints = 0;
            let calculationText = '';

            if (p.bid === p.tricksWon) {
                if (p.bid === 7) {
                    roundPoints = (p.bid * 15) + 30;
                    calculationText = `(${p.bid} x 15) + 30 bonuss = ${roundPoints}`;
                } else {
                    roundPoints = p.bid * 15;
                    calculationText = `${p.bid} x 15 = ${roundPoints}`;
                }
            } else {
                if (p.bid === 7 && p.tricksWon < 7) {
                    roundPoints = -30;
                    calculationText = `NeizpildÄ«ts 7 stiÄ·u solÄ«jums = ${roundPoints}`;
                } else if (p.tricksWon < p.bid) {
                    const tricksMissed = p.bid - p.tricksWon;
                    roundPoints = -5 * tricksMissed;
                    calculationText = `-5 x ${tricksMissed} nepaÅ†emti stiÄ·i = ${roundPoints}`;
                } else {
                    roundPoints = p.tricksWon * 5;
                    calculationText = `${p.tricksWon} x 5 = ${roundPoints}`;
                }
            }
            p.score += roundPoints;

            const pointsClass = roundPoints >= 15 ? 'text-green-400' : (roundPoints > 0 ? 'text-yellow-400' : 'text-red-400');
            const resultRow = document.createElement('div');
            resultRow.className = 'result-row';
            resultRow.innerHTML = `
                <div class="flex justify-between items-center">
                    <span class="player-name">${p.name}</span>
                    <span class="points-calculation ${pointsClass}">
                        ${roundPoints >= 0 ? '+' : ''}${roundPoints} ${translations[currentLanguage].pointsSuffix}
                    </span>
                </div>
                <div class="bid-info">
                    ${translations[currentLanguage].roundResultText(p.bid, p.tricksWon)}
                </div>
                <div class="bid-info text-xs italic opacity-80">
                    ${calculationText}
                </div>`;
            roundResultsBody.appendChild(resultRow);
        });
        
        updateScoreboard(); 
        roundOverModal.classList.remove('hidden'); 
    }

    function showGameOver() {
        gameState = 'gameover';
        const sortedPlayers = [...players].sort((a,b) => b.score - a.score);
        const winner = sortedPlayers[0];
        document.getElementById('game-over-winner').textContent = translations[currentLanguage].winnerIs(winner.name, winner.score);
        const finalScoresEl = document.getElementById('final-scores');
        finalScoresEl.innerHTML = `<h4 class="text-lg font-bold mb-2">${translations[currentLanguage].finalScoresTitle}</h4>`;
        sortedPlayers.forEach(p => finalScoresEl.innerHTML += `<p class="flex justify-between"><span>${p.name}:</span> <span>${p.score} ${translations[currentLanguage].pointsSuffix}</span></p>`);
        
        const animationContainer = document.getElementById('winner-animation-container');
        animationContainer.innerHTML = '<div class="winner-cup">ğŸ†</div>';
        gameOverModal.classList.remove('hidden');
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    // --- GEMINI API ---
    async function callGemini(prompt) {
        const geminiModalContent = document.getElementById('gemini-modal-content');
        geminiModal.classList.remove('hidden');
        geminiModalContent.innerHTML = `<div class="loader-container flex justify-center items-center"><div class="loader"></div></div>`;

        const apiKey = ""; // API key is managed by the environment
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
        const payload = { contents: chatHistory };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const text = result.candidates[0].content.parts[0].text;
                geminiModalContent.innerHTML = `<p class="whitespace-pre-wrap">${text}</p>`;
            } else {
                 throw new Error("Invalid response structure from API.");
            }
        } catch (error) {
            console.error("Gemini API call failed:", error);
            geminiModalContent.textContent = "Atvainojiet, radÄs kÄ¼Å«da, sazinoties ar AI padomdevÄ“ju. LÅ«dzu, mÄ“Ä£iniet vÄ“lÄk.";
        }
    }

    function handleGetAdvice() {
        const player = players[3];
        const handString = player.hand.map(d => d.originalId).join(', ');
        const trickString = trick.map(p => `${p.domino.originalId} (spÄ“lÄ“ja ${players[p.playerIndex].name})`).join(', ') || 'nav';
        
        const prompt = `You are a world-class Domino Pokers strategy expert. Your goal is to advise a human player to make the best possible move. The game is similar to Spades or Bridge. Trumps are very powerful. Aces (doubles) are also powerful. The player must follow suit if they can. Here is the current situation:
- My hand: [${handString}]
- I bid ${player.bid} and I have already won ${player.tricksWon} tricks.
- The other players' bids are: JÄnis (${players[0].bid}), PÄ“teris (${players[1].bid}), Andris (${players[2].bid}).
- It is my turn to play.
- Dominoes already played in this trick: ${trickString}
- The suit to follow is: ${trickSuit === null ? 'any' : (trickSuit === 'trump' ? 'trumps' : trickSuit)}.

Based on this, what is the best domino for me to play from my hand and why? Provide a concise strategic reason. Explain your choice in Latvian.`;

        document.getElementById('gemini-modal-title').textContent = translations[currentLanguage].adviceTitle;
        callGemini(prompt);
    }
    
    function handleAnalyzeRound() {
        const results = players.map(p => {
            return `- SpÄ“lÄ“tÄjs '${p.name}' solÄ«ja ${p.bid}, paÅ†Ä“ma ${p.tricksWon}.`;
        }).join('\n');

        const prompt = `You are a sharp-witted Domino Pokers commentator. Briefly analyze the round that just finished. Be insightful and a little entertaining. Here are the results:\n${results}\n\nProvide a short, one-paragraph analysis of the round in Latvian. Who was the star player and who made a blunder?`;
        
        document.getElementById('gemini-modal-title').textContent = translations[currentLanguage].analysisTitle;
        callGemini(prompt);
    }
    
    // --- EVENT LISTENERS ---
    function updateAutoplayButton() {
        autoplayBtn.classList.toggle('btn-toggle-on', isPlayerAutoplaying);
        autoplayBtn.textContent = isPlayerAutoplaying 
            ? translations[currentLanguage].disableAutoplay 
            : translations[currentLanguage].enableAutoplay;
    }

    function toggleAutoplay() {
        isPlayerAutoplaying = !isPlayerAutoplaying;
        players[3].name = isPlayerAutoplaying ? `${translations[currentLanguage].you} (CPU)` : translations[currentLanguage].you;
        updateAutoplayButton();
        updatePlayerHandClickability();
    }
    
    function setAutoplaySpeed(speed) {
        autoplaySpeed = speed;
        document.getElementById('speed-1x').classList.toggle('active', speed === 1);
        document.getElementById('speed-2x').classList.toggle('active', speed === 2);
        document.getElementById('speed-3x').classList.toggle('active', speed === 3);
    }
    document.getElementById('speed-1x').addEventListener('click', () => setAutoplaySpeed(1));
    document.getElementById('speed-2x').addEventListener('click', () => setAutoplaySpeed(2));
    document.getElementById('speed-3x').addEventListener('click', () => setAutoplaySpeed(3));

    document.getElementById('start-game-btn').addEventListener('click', () => {
        document.getElementById('rounds-modal').classList.add('hidden');
        totalRounds = parseInt(document.getElementById('rounds-input').value) || 5;
        runGame();
    });
    document.getElementById('play-again-btn').addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        document.getElementById('rounds-modal').classList.remove('hidden');
    });

    document.getElementById('next-round-btn').addEventListener('click', () => {
        roundOverModal.classList.add('hidden');
        if (resolveNextRound) {
            resolveNextRound();
        }
    });

    autoplayBtn.addEventListener('click', toggleAutoplay);
    document.getElementById('lang-lv').addEventListener('click', () => setLanguage('lv'));
    document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));

    geminiAdviceBtn.addEventListener('click', handleGetAdvice);
    geminiAnalysisBtn.addEventListener('click', handleAnalyzeRound);
    document.getElementById('gemini-modal-close-btn').addEventListener('click', () => geminiModal.classList.add('hidden'));
    
    helpBtn.addEventListener('click', () => {
        const rulesData = rules[currentLanguage];
        document.getElementById('rules-modal-title').textContent = rulesData.title;
        document.getElementById('rules-modal-content').innerHTML = rulesData.content;
        rulesModal.classList.remove('hidden');
    });
    document.getElementById('rules-modal-close-btn').addEventListener('click', () => rulesModal.classList.add('hidden'));

    setLanguage('lv');

    // ===================================================
    // CPU STRATÄ’Ä¢IJA
    // ===================================================
    function getCPUBid(player) {
        let estimatedTricks = 0;
        player.hand.forEach(domino => {
            const type = getDominoType(domino);
            if (type === 'trump') {
                const trumpRank = trumps.indexOf(domino.id);
                if (trumpRank <= 2) estimatedTricks += 1.0;
                else if (trumpRank <= 4) estimatedTricks += 0.7;
                else estimatedTricks += 0.4;
            } else if (type === 'ace') {
                const suit = domino.pips1;
                const supportCards = player.hand.filter(d => d.id !== domino.id && (d.pips1 === suit || d.pips2 === suit)).length;
                let aceSafety = 0.15;
                if (supportCards === 1) aceSafety = 0.5;
                if (supportCards === 2) aceSafety = 0.8;
                if (supportCards >= 3) aceSafety = 0.95;
                estimatedTricks += aceSafety;
            }
        });
        const trumpCount = player.hand.filter(d => getDominoType(d) === 'trump').length;
        if (trumpCount === 0 && estimatedTricks > 1.5) estimatedTricks -= 0.75;
        if (trumpCount >= 4) estimatedTricks += 0.5;
        return Math.max(0, Math.min(7, Math.round(estimatedTricks)));
    }
    function getCPUMove(player) {
        const validMoves = player.hand.filter(d => isMoveValid(d, player));
        let objective = (player.bid === 0) ? 'DISRUPT' : (player.tricksWon < player.bid ? 'WIN' : 'LOSE');
        
        if (trick.length === 0) {
            let move, suitToLead = -1;
            if (objective === 'WIN') {
                const potentialWinners = validMoves.filter(d => getDominoType(d) === 'ace' || getDominoType(d) === 'trump').sort((a, b) => getDominoRank(b, null) - getDominoRank(a, null));
                move = potentialWinners.length > 0 ? potentialWinners[0] : validMoves.sort((a,b) => getDominoRank(b, null) - getDominoRank(a, null))[0];
            } else {
                const safeToLose = validMoves.filter(d => getDominoType(d) === 'normal');
                move = safeToLose.length > 0 ? safeToLose.sort((a,b) => getDominoRank(a, null) - getDominoRank(b, null))[0] : validMoves.sort((a,b) => getDominoRank(a, null) - getDominoRank(b, null))[0];
            }
            if (getDominoType(move) !== 'trump') {
                if(move.id === '0-6') { suitToLead = (objective === 'WIN') ? 0 : 6; } 
                else { suitToLead = roundState.suitsPlayed[move.pips1] <= roundState.suitsPlayed[move.pips2] ? move.pips1 : move.pips2; }
            }
            return { domino: move, suitToLead: suitToLead };
        }
        
        const winningMoves = validMoves.filter(move => determineTrickWinner([...trick, { domino: move, playerIndex: player.id }]).playerIndex === player.id);
        const losingMoves = validMoves.filter(move => !winningMoves.some(w => w.originalId === move.originalId));
        
        if (objective === 'WIN') {
            if (winningMoves.length > 0) return { domino: winningMoves.sort((a, b) => getDominoRank(a, trickSuit) - getDominoRank(b, trickSuit))[0] };
            return { domino: validMoves.sort((a, b) => getDominoRank(a, null) - getDominoRank(b, null))[0] };
        } else if (objective === 'LOSE') {
            if (losingMoves.length > 0) return { domino: losingMoves.sort((a, b) => getDominoRank(b, null) - getDominoRank(a, null))[0] };
            return { domino: winningMoves.sort((a, b) => getDominoRank(a, trickSuit) - getDominoRank(b, trickSuit))[0] };
        } else { // DISRUPT
            if (winningMoves.length > 0) return { domino: winningMoves.sort((a, b) => getDominoRank(b, trickSuit) - getDominoRank(a, trickSuit))[0] };
            return { domino: losingMoves.length > 0 ? losingMoves.sort((a, b) => getDominoRank(a, null) - getDominoRank(b, null))[0] : validMoves[0] };
        }
    }
});
</script>
</body>
</html>